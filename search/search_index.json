{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"idendrogram","text":""},{"location":"#idendrogram","title":"idendrogram\u00b6","text":"<p><code>idendrogram</code> helps you create nicer, interactive visualizations of hierarchical clustering trees (a.k.a. dendrograms) from clustering outputs generated by your preferred hierarchical clustering library (SciPy, Scikit-learn or HDBSCAN) in your preferred python visualization library (Altair, Plotly or Matplotlib)</p> <p>It also supports bi-directional Streamlit integration via a custom D3-powered component.</p>"},{"location":"#gallery","title":"Gallery\u00b6","text":"<p><code>idendrogram</code> supports custom tooltips, customization of colors, leaf labels, rotation and nearly any other attribute of nodes and links in dendrograms.</p> <p>Be sure to also check out interactive Streamlit demos!</p> <p></p>"},{"location":"#bi-directional-streamlit-integration","title":"Bi-directional Streamlit integration\u00b6","text":""},{"location":"#customizable-interactive-tooltips","title":"Customizable interactive tooltips\u00b6","text":""},{"location":"#customizable-node-radii","title":"Customizable node radii\u00b6","text":""},{"location":"#full-control-of-colors","title":"Full control of colors\u00b6","text":""},{"location":"#customization-of-pretty-much-any-aspect","title":"Customization of pretty much any aspect\u00b6","text":""},{"location":"#installation","title":"Installation\u00b6","text":"<p>To use the main package:</p> <p><code>pip install idendrogram</code></p> <p>To use the bi-directional Streamlit component:</p> <p><code>pip install idendrogram idendrogram-streamlit-component</code></p>"},{"location":"#usage","title":"Usage\u00b6","text":"<p>See Getting Started for usage examples.</p>"},{"location":"getting-started/","title":"Getting started","text":"In\u00a0[2]: Copied! <pre>import idendrogram\nimport scipy.cluster.hierarchy as sch\nfrom idendrogram.targets.altair import to_altair\n\n#cluster the data\nlinkage_matrix = sch.linkage(\n    data['data'], method='single', metric='euclidean'\n)\nthreshold = 0.8\nflat_clusters = sch.fcluster(\n    linkage_matrix, t=threshold, criterion='distance'\n)\n\n#wrap clustering outputs / parameters into a container\ncl_data = idendrogram.ClusteringData(\n    linkage_matrix = linkage_matrix, \n    cluster_assignments = flat_clusters\n)\n\n#pass to idendrogram and visualize\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\ndendrogram = idd.create_dendrogram(truncate_mode='level', p=10)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> import idendrogram import scipy.cluster.hierarchy as sch from idendrogram.targets.altair import to_altair  #cluster the data linkage_matrix = sch.linkage(     data['data'], method='single', metric='euclidean' ) threshold = 0.8 flat_clusters = sch.fcluster(     linkage_matrix, t=threshold, criterion='distance' )  #wrap clustering outputs / parameters into a container cl_data = idendrogram.ClusteringData(     linkage_matrix = linkage_matrix,      cluster_assignments = flat_clusters )  #pass to idendrogram and visualize idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data) dendrogram = idd.create_dendrogram(truncate_mode='level', p=10) to_altair(dendrogram=dendrogram, height=200, width=629) Out[2]: In\u00a0[3]: Copied! <pre>import os, sys\nsys.path.insert(1, os.path.join(sys.path[0], '../..'))\nimport altair \naltair.renderers.set_embed_options(actions=False)\npass\n</pre> import os, sys sys.path.insert(1, os.path.join(sys.path[0], '../..')) import altair  altair.renderers.set_embed_options(actions=False) pass In\u00a0[4]: Copied! <pre>import scipy.cluster.hierarchy as sch\nfrom sklearn.datasets import load_iris\nimport idendrogram\n\n# do the usual scipy hierarchical clustering\ndata = load_iris(as_frame=True)\nlinkage_matrix = sch.linkage(\n    data['data'], method='single', metric='euclidean'\n)\nflat_clusters = sch.fcluster(\n    linkage_matrix, t=0.8, criterion='distance'\n)\n\n#pass it to idendrogram and visualize\ncl_data = idendrogram.ClusteringData(\n    linkage_matrix = linkage_matrix, \n    cluster_assignments = flat_clusters\n)\n\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\n\nidd.create_dendrogram().plot(\n    backend='altair',\n    height=200, width=629,\n)\n</pre> import scipy.cluster.hierarchy as sch from sklearn.datasets import load_iris import idendrogram  # do the usual scipy hierarchical clustering data = load_iris(as_frame=True) linkage_matrix = sch.linkage(     data['data'], method='single', metric='euclidean' ) flat_clusters = sch.fcluster(     linkage_matrix, t=0.8, criterion='distance' )  #pass it to idendrogram and visualize cl_data = idendrogram.ClusteringData(     linkage_matrix = linkage_matrix,      cluster_assignments = flat_clusters )  idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data)  idd.create_dendrogram().plot(     backend='altair',     height=200, width=629, ) Out[4]: In\u00a0[5]: Copied! <pre>## create a scipy dendrogram object\nD = sch.dendrogram(\n    linkage_matrix, \n    p=4, truncate_mode=\"level\",\n    no_plot=True\n)\n</pre> ## create a scipy dendrogram object D = sch.dendrogram(     linkage_matrix,      p=4, truncate_mode=\"level\",     no_plot=True ) <p>If you have just the dendrogram object (and not the underlying linkage matrix), you cannot compute/plot the nodes in the dendrogram, but you can still use the available backends.</p> In\u00a0[6]: Copied! <pre>## pass it to idendrogram and visualize\nidd = idendrogram.idendrogram()\nidd.convert_scipy_dendrogram(D, compute_nodes=False).plot(\n    backend='altair',\n    height=200, width=629,\n    show_nodes=False\n)\n</pre> ## pass it to idendrogram and visualize idd = idendrogram.idendrogram() idd.convert_scipy_dendrogram(D, compute_nodes=False).plot(     backend='altair',     height=200, width=629,     show_nodes=False ) Out[6]: <p>Note that not all customization functionality is available when using SciPy's dendrogram objects. In most cases, it is recommended that you generate the dendrogram with idendrogram itself.</p> In\u00a0[7]: Copied! <pre>from sklearn.cluster import AgglomerativeClustering\nfrom sklearn.datasets import load_iris\nimport idendrogram\n\ndata = load_iris(as_frame=True)\n\n# do the usual scikit-learn hierarchical clustering\nmodel = AgglomerativeClustering(\n    distance_threshold=0.8,\n    linkage='single',\n    n_clusters=None\n).fit(data['data'])\n\n#pass it to idendrogram and visualize\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(idendrogram.ScikitLearnClusteringData(model))\n\nidd.create_dendrogram().plot(\n    backend='altair',\n    height=200, width=629\n)\n</pre> from sklearn.cluster import AgglomerativeClustering from sklearn.datasets import load_iris import idendrogram  data = load_iris(as_frame=True)  # do the usual scikit-learn hierarchical clustering model = AgglomerativeClustering(     distance_threshold=0.8,     linkage='single',     n_clusters=None ).fit(data['data'])  #pass it to idendrogram and visualize idd = idendrogram.idendrogram() idd.set_cluster_info(idendrogram.ScikitLearnClusteringData(model))  idd.create_dendrogram().plot(     backend='altair',     height=200, width=629 ) Out[7]: In\u00a0[8]: Copied! <pre>import hdbscan\nclusterer = hdbscan.HDBSCAN()\nclusterer.fit(data['data'])\n\n#pass it to idendrogram and visualize\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(idendrogram.HDBSCANClusteringData(clusterer))\n\nidd.create_dendrogram().plot(\n    backend='altair',\n    height=200, width=629\n)\n</pre> import hdbscan clusterer = hdbscan.HDBSCAN() clusterer.fit(data['data'])  #pass it to idendrogram and visualize idd = idendrogram.idendrogram() idd.set_cluster_info(idendrogram.HDBSCANClusteringData(clusterer))  idd.create_dendrogram().plot(     backend='altair',     height=200, width=629 ) Out[8]: In\u00a0[9]: Copied! <pre>import altair \naltair.renderers.set_embed_options(actions=False)\npass\n</pre> import altair  altair.renderers.set_embed_options(actions=False) pass In\u00a0[10]: Copied! <pre>import scipy.cluster.hierarchy as sch\nfrom sklearn.datasets import load_iris\nimport idendrogram\nfrom matplotlib import pyplot as plt\n\n# do the usual scipy hierarchical clustering\ndata = load_iris(as_frame=True)\nlinkage_matrix = sch.linkage(\n    data['data'], method='single', metric='euclidean'\n)\nflat_clusters = sch.fcluster(\n    linkage_matrix, t=0.8, criterion='distance'\n)\n\n#pass it to idendrogram and visualize\ncl_data = idendrogram.ClusteringData(\n    linkage_matrix = linkage_matrix, \n    cluster_assignments = flat_clusters\n)\n\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\n\ndendrogram = idd.create_dendrogram()\n</pre> import scipy.cluster.hierarchy as sch from sklearn.datasets import load_iris import idendrogram from matplotlib import pyplot as plt  # do the usual scipy hierarchical clustering data = load_iris(as_frame=True) linkage_matrix = sch.linkage(     data['data'], method='single', metric='euclidean' ) flat_clusters = sch.fcluster(     linkage_matrix, t=0.8, criterion='distance' )  #pass it to idendrogram and visualize cl_data = idendrogram.ClusteringData(     linkage_matrix = linkage_matrix,      cluster_assignments = flat_clusters )  idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data)  dendrogram = idd.create_dendrogram() In\u00a0[11]: Copied! <pre>dendrogram.plot(\n    backend='altair',\n    height=200, width=629,    \n)\n</pre> dendrogram.plot(     backend='altair',     height=200, width=629,     ) Out[11]: In\u00a0[12]: Copied! <pre>dendrogram.plot(\n    backend='plotly',\n    height=400, width=650,\n)\n</pre> dendrogram.plot(     backend='plotly',     height=400, width=650, ) In\u00a0[13]: Copied! <pre>dendrogram.plot(\n    backend='matplotlib',\n    height=300, width=750,\n    show_nodes=True\n)\nplt.show()\n</pre> dendrogram.plot(     backend='matplotlib',     height=300, width=750,     show_nodes=True ) plt.show() <p>idendrogram aims to produce identical outputs no matter what the visualization frontend is used (visualization library defaults not withstanding). However, this is not always possible. Some caveats include:</p> <ul> <li><code>symlog</code> scale type is not supported by Plotly;</li> <li><code>ClusterLink.strokedash</code> property may need to be tweaked to achieve identically looking results among the libraries</li> <li>Matplotlib functionality is limited to static charts; attempt is made to convert most size parameters to pixels (in line with Altair and Plotly), but some differences may remain.</li> </ul> <p>In case idendrogram does not produce the required result out of the box, see Customizing other attributes section for guidance on how to make further customizations that fit your needs.</p>"},{"location":"getting-started/#getting-started","title":"Getting started\u00b6","text":"<p>idendrogram integrates seamlessly with outputs from your favorite hierarchical clustering library, with one-line drop-ins for SciPy, HDBScan and Scikit-learn agglomerative clustering, while dendrograms can be visualized in Plotly, Altair and Matplotlib (limited support). Switching visualization frontends is as simple as passing an argument to the <code>plot()</code> function.</p>"},{"location":"getting-started/#basic-usage","title":"Basic usage\u00b6","text":""},{"location":"getting-started/#clustering-library-integration","title":"Clustering library integration\u00b6","text":""},{"location":"getting-started/#scipyhierarchycluster","title":"scipy.hierarchy.cluster\u00b6","text":"<p>idendrogram is built to support SciPy's hierarchical clustering data structures (linkage matrix and flat cluster assignments). As a result, using idendrogram is as simple as passing outputs of <code>scipy.cluster.hierarchy.linkage</code> and <code>scipy.cluster.hierarchy.fcluster</code> functions.</p>"},{"location":"getting-started/#using-previously-created-scipys-dendrogram-objects","title":"Using previously created SciPy's dendrogram objects\u00b6","text":"<p>In some situations, you may have a dendrogram object created by SciPy that you want to visualize using idendrogram. That's possible, too.</p>"},{"location":"getting-started/#sklearnclusteragglomerativeclustering","title":"sklearn.cluster.AgglomerativeClustering\u00b6","text":"<p>To use scikit-learn agglomerative clustering outputs, wrap the fit object with <code>idendrogram.ScikitLearnClusteringData</code> before passing it to idendrogram.</p>"},{"location":"getting-started/#hdbscan","title":"HDBSCAN\u00b6","text":"<p>idendrogram can visualize HDBSCAN clustering results, too. Wrap the HDBSCAN model object with <code>idendrogram.HDBSCANClusteringData</code> before passing it as clustering information. The model object is available via <code>cluster_data.get_model()</code> function in all callback functions (see case studies for ideas on how it can be leveraged).</p>"},{"location":"getting-started/#visualization-backend-support","title":"Visualization backend support\u00b6","text":"<p>idendrogram can visualize dendrograms in Plotly, Altair and Matplotlib (limited support). Switching visualization frontends is as simple as passing an argument to the <code>plot()</code> function.</p> <p>Alternatively, you can also use helper functions available at <code>idendrogram.targets</code> (<code>to_altair</code>, <code>to_plotly</code>, <code>to_matplotlib</code>, <code>to_json</code>).</p>"},{"location":"getting-started/#altair","title":"Altair\u00b6","text":""},{"location":"getting-started/#plotly","title":"Plotly\u00b6","text":""},{"location":"getting-started/#matplotlib","title":"Matplotlib\u00b6","text":""},{"location":"getting-started/#compatibility-differences","title":"Compatibility differences\u00b6","text":""},{"location":"plotly_fix/","title":"Plotly fix","text":"In\u00a0[1]: Copied! <pre>import re\n</pre> import re In\u00a0[2]: Copied! <pre>def on_page_content(html: str, **kwargs) -&gt; str:\n    \n    # Fix plots in jupyter notebook\n    html = re.sub(r'(?&lt;=&lt;script type=\"text\\/javascript\"&gt;)\\s*?require\\(\\[\"plotly\"\\], function\\(Plotly\\) {\\s*?(?=window\\.PLOTLYENV)', \"\", html)\n    html = re.sub(r'\\).then\\(function\\(\\){.*?(?=&lt;\\/script&gt;)', ')}', html, flags=re.S)    \n    return html\n</pre> def on_page_content(html: str, **kwargs) -&gt; str:          # Fix plots in jupyter notebook     html = re.sub(r'(?&lt;="},{"location":"streamlit/","title":"Streamlit usage","text":"In\u00a0[2]: Copied! <pre>import idendrogram\nimport scipy.cluster.hierarchy as sch\nfrom idendrogram.targets.streamlit import to_streamlit\n\n#cluster the data\nlinkage_matrix = sch.linkage(\n    data['data'], method='single', metric='euclidean'\n)\nthreshold = 0.8\nflat_clusters = sch.fcluster(\n    linkage_matrix, t=threshold, criterion='distance'\n)\n\n#wrap clustering outputs / parameters into a container\ncl_data = idendrogram.ClusteringData(\n    linkage_matrix = linkage_matrix, \n    cluster_assignments = flat_clusters\n)\n\n#pass to idendrogram and create a dendrogram object\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\ndendrogram = idd.create_dendrogram(truncate_mode='level', p=10)\n\n#visualize in streamlit and get the data object behind the selected node\n#selected_node = to_streamlit(dendrogram=dendrogram, height=200, width=629)\n</pre> import idendrogram import scipy.cluster.hierarchy as sch from idendrogram.targets.streamlit import to_streamlit  #cluster the data linkage_matrix = sch.linkage(     data['data'], method='single', metric='euclidean' ) threshold = 0.8 flat_clusters = sch.fcluster(     linkage_matrix, t=threshold, criterion='distance' )  #wrap clustering outputs / parameters into a container cl_data = idendrogram.ClusteringData(     linkage_matrix = linkage_matrix,      cluster_assignments = flat_clusters )  #pass to idendrogram and create a dendrogram object idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data) dendrogram = idd.create_dendrogram(truncate_mode='level', p=10)  #visualize in streamlit and get the data object behind the selected node #selected_node = to_streamlit(dendrogram=dendrogram, height=200, width=629)"},{"location":"streamlit/#streamlit-usage","title":"Streamlit usage\u00b6","text":"<p>To use idendrogram in Streamlit, make sure you have installed the accompanying package <code>idendrogram-streamlit-component</code>. If you have not installed it together with idendrogram, get it:</p> <p><code>pip install idendrogram_streamlit_component</code></p> <p>The usage is identical to any other visualization backend. The key difference is that <code>to_streamlit()</code> function returns <code>ClusterNode</code> object if the user clicks on any of the nodes in the dendrogram. This allows creating interactive experiences where the user can get more information about a particular (sub/super) cluster in a dendrogram.</p> <p>.</p>"},{"location":"streamlit/#customizing-streamlit-dendrograms","title":"Customizing Streamlit dendrograms\u00b6","text":"<p>Developers familiar with D3 may want to customize the dendrogram component further (e.g. create richer tooltips). The source of the streamlit component with some guidance on its structure is available at https://github.com/kamicollo/idendrogram-streamlit.</p> <p>Assuming you have the <code>node.js</code> server running locally that's serving the Streamlit component, you can get the <code>idendrogram_streamlit_component</code> to point to the local version as follows:</p> <pre>from idendrogram_streamlit_component import StreamlitConverter\n\n#set release flag to False\nconverter = StreamlitConverter(release=False)\n\n#pass to idendrogram and create a dendrogram object\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\ndendrogram = idd.create_dendrogram(truncate_mode='level', p=10)\n\n#render in Streamlit\nconverter.convert(\n    dendrogram,\n    height=500,\n    width=500,\n    scale='linear',\n    key='idendrogram',\n    orientation = 'top',\n    show_nodes = True,\n    margins = {'top': 50, 'bottom': 50, 'left': 50, 'right': 50}\n)\n</pre>"},{"location":"streamlit/#adjusting-streamlit-dendrogram-margins","title":"Adjusting Streamlit dendrogram margins\u00b6","text":"<p>The same method as above can be used to pass custom margins to be used to render the dendrogram. Just do not set <code>release=False</code>, but use the <code>StreamlitConverter</code> to pass custom margins instead.</p>"},{"location":"case-studies/demo_func/","title":"Demo func","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport networkx as nx\nimport random\nimport pywt as pywt\nfrom scipy.sparse import csr_matrix\nfrom sklearn.metrics import pairwise_distances\nfrom scipy.spatial.distance import squareform\n</pre> import numpy as np import networkx as nx import random import pywt as pywt from scipy.sparse import csr_matrix from sklearn.metrics import pairwise_distances from scipy.spatial.distance import squareform In\u00a0[2]: Copied! <pre>class DemoData():\n    no_signals: int\n    rnd = None\n    ideal_signal = None\n\n\n\n    def __init__(self, no_signals = 100, seed = 833142, no_network_clusters = 12) -&gt; None:\n        self.rnd = np.random.default_rng(seed=seed)\n        self.no_signals = no_signals\n        self.no_network_clusters = no_network_clusters\n\n\n    def generate_raw_data(self):        \n        X = np.linspace(1,1000,1000)\n        unused = [(0,200), (450,520), (550, 580), (700,850), (940,1000)]\n        self.ideal_signal = np.ones(X.shape) * 20\n        for start,stop in unused:\n            self.ideal_signal[start:stop] = -50        \n        noise = self.rnd.normal(0, 1, size=(self.no_signals,1000))\n        self.signals = noise + self.ideal_signal\n        return self.signals\n\n\n    def generate_impaired_graph(self, impairments):\n        graph = nx.DiGraph()\n        \n        clusters = np.arange(self.no_network_clusters)    \n        cluster_assignments = self.rnd.choice(clusters, self.no_signals, replace=True)\n        cluster_set  = set(clusters)\n        i = self.no_network_clusters\n        while len(cluster_set) &gt; 1:\n            c1, c2 = self.rnd.choice(list(cluster_set), 2, replace=False)\n            cluster_set.discard(c1)\n            cluster_set.discard(c2)\n            cluster_set.add(i)\n            graph.add_edges_from([(i, c1), (i, c2)])\n            i += 1\n\n        nx.set_node_attributes(graph, \"blue\", \"color\")\n        attrs = {id: {\"color\": color} for id, color, _, _ in impairments.values()}\n        nx.set_node_attributes(graph, attrs)\n\n        imp_signals = self.signals.copy()\n        for imp_name, (edge, _, imp_x, imp_y) in impairments.items():\n            affected_children = [y for _,y in nx.edge_dfs(graph, edge)]\n            affected_clusters = [x for x in affected_children + [edge] if x &lt; self.no_network_clusters]\n            for cluster in affected_clusters:\n                rel_signals = imp_signals[cluster_assignments == cluster,:]\n                rel_signals[:,imp_x] += imp_y\n                imp_signals[cluster_assignments == cluster,:] = rel_signals\n        \n        self.impaired_signals = imp_signals\n        self.graph = graph\n        self.network_clusters = cluster_assignments\n\n        return (graph, self.impaired_signals, cluster_assignments)\n\n\n    def get_sparse_wavelet_matrix(self, signals):\n        coeffs = pywt.wavedec(signals, \"db1\", mode='zero', level=7, axis=1) #list of 7 x [100 x #no_coeffs]\n        unraveled = coeffs[0]\n        for level in coeffs[1:]:\n            unraveled = np.concatenate([unraveled, level], axis=1)\n\n        unraveled[np.abs(unraveled) &lt; 30] = 0 #threshold at a hardcoded value of 30 (chosen based on experience)\n        sparse_matrix = csr_matrix(unraveled)\n        return sparse_matrix\n\n    def get_adjacency_matrix(self, sparse_matrix):\n        pdists = pairwise_distances(sparse_matrix, metric='cityblock')            \n        dists = squareform(pdists)   \n        return dists\n</pre> class DemoData():     no_signals: int     rnd = None     ideal_signal = None        def __init__(self, no_signals = 100, seed = 833142, no_network_clusters = 12) -&gt; None:         self.rnd = np.random.default_rng(seed=seed)         self.no_signals = no_signals         self.no_network_clusters = no_network_clusters       def generate_raw_data(self):                 X = np.linspace(1,1000,1000)         unused = [(0,200), (450,520), (550, 580), (700,850), (940,1000)]         self.ideal_signal = np.ones(X.shape) * 20         for start,stop in unused:             self.ideal_signal[start:stop] = -50                 noise = self.rnd.normal(0, 1, size=(self.no_signals,1000))         self.signals = noise + self.ideal_signal         return self.signals       def generate_impaired_graph(self, impairments):         graph = nx.DiGraph()                  clusters = np.arange(self.no_network_clusters)             cluster_assignments = self.rnd.choice(clusters, self.no_signals, replace=True)         cluster_set  = set(clusters)         i = self.no_network_clusters         while len(cluster_set) &gt; 1:             c1, c2 = self.rnd.choice(list(cluster_set), 2, replace=False)             cluster_set.discard(c1)             cluster_set.discard(c2)             cluster_set.add(i)             graph.add_edges_from([(i, c1), (i, c2)])             i += 1          nx.set_node_attributes(graph, \"blue\", \"color\")         attrs = {id: {\"color\": color} for id, color, _, _ in impairments.values()}         nx.set_node_attributes(graph, attrs)          imp_signals = self.signals.copy()         for imp_name, (edge, _, imp_x, imp_y) in impairments.items():             affected_children = [y for _,y in nx.edge_dfs(graph, edge)]             affected_clusters = [x for x in affected_children + [edge] if x &lt; self.no_network_clusters]             for cluster in affected_clusters:                 rel_signals = imp_signals[cluster_assignments == cluster,:]                 rel_signals[:,imp_x] += imp_y                 imp_signals[cluster_assignments == cluster,:] = rel_signals                  self.impaired_signals = imp_signals         self.graph = graph         self.network_clusters = cluster_assignments          return (graph, self.impaired_signals, cluster_assignments)       def get_sparse_wavelet_matrix(self, signals):         coeffs = pywt.wavedec(signals, \"db1\", mode='zero', level=7, axis=1) #list of 7 x [100 x #no_coeffs]         unraveled = coeffs[0]         for level in coeffs[1:]:             unraveled = np.concatenate([unraveled, level], axis=1)          unraveled[np.abs(unraveled) &lt; 30] = 0 #threshold at a hardcoded value of 30 (chosen based on experience)         sparse_matrix = csr_matrix(unraveled)         return sparse_matrix      def get_adjacency_matrix(self, sparse_matrix):         pdists = pairwise_distances(sparse_matrix, metric='cityblock')                     dists = squareform(pdists)            return dists In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[3]: Copied! <pre>def hierarchy_pos(G, root=None, width=1., vert_gap = 0.2, vert_loc = 0, xcenter = 0.5):\n\n'''\n    From Joel's answer at https://stackoverflow.com/a/29597209/2966723.  \n    Licensed under Creative Commons Attribution-Share Alike \n    If the graph is a tree this will return the positions to plot this in a \n    hierarchical layout.\n    G: the graph (must be a tree)\n    root: the root node of current branch \n    - if the tree is directed and this is not given, \n      the root will be found and used\n    - if the tree is directed and this is given, then \n      the positions will be just for the descendants of this node.\n    - if the tree is undirected and not given, \n      then a random choice will be used.\n    width: horizontal space allocated for this branch - avoids overlap with other branches\n    vert_gap: gap between levels of hierarchy\n    vert_loc: vertical location of root\n    xcenter: horizontal location of root\n    '''\n    if not nx.is_tree(G):\n        raise TypeError('cannot use hierarchy_pos on a graph that is not a tree')\n\n    if root is None:\n        if isinstance(G, nx.DiGraph):\n            root = next(iter(nx.topological_sort(G)))  #allows back compatibility with nx version 1.11\n        else:\n            root = random.choice(list(G.nodes))\n</pre> def hierarchy_pos(G, root=None, width=1., vert_gap = 0.2, vert_loc = 0, xcenter = 0.5):      '''     From Joel's answer at https://stackoverflow.com/a/29597209/2966723.       Licensed under Creative Commons Attribution-Share Alike           If the graph is a tree this will return the positions to plot this in a      hierarchical layout.          G: the graph (must be a tree)          root: the root node of current branch      - if the tree is directed and this is not given,        the root will be found and used     - if the tree is directed and this is given, then        the positions will be just for the descendants of this node.     - if the tree is undirected and not given,        then a random choice will be used.          width: horizontal space allocated for this branch - avoids overlap with other branches          vert_gap: gap between levels of hierarchy          vert_loc: vertical location of root          xcenter: horizontal location of root     '''     if not nx.is_tree(G):         raise TypeError('cannot use hierarchy_pos on a graph that is not a tree')      if root is None:         if isinstance(G, nx.DiGraph):             root = next(iter(nx.topological_sort(G)))  #allows back compatibility with nx version 1.11         else:             root = random.choice(list(G.nodes)) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[4]: Copied! <pre>def hierarchy_pos(G, root=None, width=1., vert_gap = 0.2, vert_loc = 0, xcenter = 0.5):\n\n'''\n    From Joel's answer at https://stackoverflow.com/a/29597209/2966723.  \n    Licensed under Creative Commons Attribution-Share Alike \n    If the graph is a tree this will return the positions to plot this in a \n    hierarchical layout.\n    G: the graph (must be a tree)\n    root: the root node of current branch \n    - if the tree is directed and this is not given, \n      the root will be found and used\n    - if the tree is directed and this is given, then \n      the positions will be just for the descendants of this node.\n    - if the tree is undirected and not given, \n      then a random choice will be used.\n    width: horizontal space allocated for this branch - avoids overlap with other branches\n    vert_gap: gap between levels of hierarchy\n    vert_loc: vertical location of root\n    xcenter: horizontal location of root\n    '''\n    if not nx.is_tree(G):\n        raise TypeError('cannot use hierarchy_pos on a graph that is not a tree')\n\n    if root is None:\n        if isinstance(G, nx.DiGraph):\n            root = next(iter(nx.topological_sort(G)))  #allows back compatibility with nx version 1.11\n        else:\n            root = random.choice(list(G.nodes))\n\n    def _hierarchy_pos(G, root, width=1., vert_gap = 0.2, vert_loc = 0, xcenter = 0.5, pos = None, parent = None):\n'''\n        see hierarchy_pos docstring for most arguments\n\n        pos: a dict saying where all nodes go if they have been assigned\n        parent: parent of this branch. - only affects it if non-directed\n\n        '''\n    \n        if pos is None:\n            pos = {root:(xcenter,vert_loc)}\n        else:\n            pos[root] = (xcenter, vert_loc)\n        children = list(G.neighbors(root))\n        if not isinstance(G, nx.DiGraph) and parent is not None:\n            children.remove(parent)  \n        if len(children)!=0:\n            dx = width/len(children) \n            nextx = xcenter - width/2 - dx/2\n            for child in children:\n                nextx += dx\n                pos = _hierarchy_pos(G,child, width = dx, vert_gap = vert_gap, \n                                    vert_loc = vert_loc-vert_gap, xcenter=nextx,\n                                    pos=pos, parent = root)\n        return pos\n\n            \n    return _hierarchy_pos(G, root, width, vert_gap, vert_loc, xcenter)\n</pre> def hierarchy_pos(G, root=None, width=1., vert_gap = 0.2, vert_loc = 0, xcenter = 0.5):      '''     From Joel's answer at https://stackoverflow.com/a/29597209/2966723.       Licensed under Creative Commons Attribution-Share Alike           If the graph is a tree this will return the positions to plot this in a      hierarchical layout.          G: the graph (must be a tree)          root: the root node of current branch      - if the tree is directed and this is not given,        the root will be found and used     - if the tree is directed and this is given, then        the positions will be just for the descendants of this node.     - if the tree is undirected and not given,        then a random choice will be used.          width: horizontal space allocated for this branch - avoids overlap with other branches          vert_gap: gap between levels of hierarchy          vert_loc: vertical location of root          xcenter: horizontal location of root     '''     if not nx.is_tree(G):         raise TypeError('cannot use hierarchy_pos on a graph that is not a tree')      if root is None:         if isinstance(G, nx.DiGraph):             root = next(iter(nx.topological_sort(G)))  #allows back compatibility with nx version 1.11         else:             root = random.choice(list(G.nodes))      def _hierarchy_pos(G, root, width=1., vert_gap = 0.2, vert_loc = 0, xcenter = 0.5, pos = None, parent = None):         '''         see hierarchy_pos docstring for most arguments          pos: a dict saying where all nodes go if they have been assigned         parent: parent of this branch. - only affects it if non-directed          '''              if pos is None:             pos = {root:(xcenter,vert_loc)}         else:             pos[root] = (xcenter, vert_loc)         children = list(G.neighbors(root))         if not isinstance(G, nx.DiGraph) and parent is not None:             children.remove(parent)           if len(children)!=0:             dx = width/len(children)              nextx = xcenter - width/2 - dx/2             for child in children:                 nextx += dx                 pos = _hierarchy_pos(G,child, width = dx, vert_gap = vert_gap,                                      vert_loc = vert_loc-vert_gap, xcenter=nextx,                                     pos=pos, parent = root)         return pos                   return _hierarchy_pos(G, root, width, vert_gap, vert_loc, xcenter)"},{"location":"case-studies/signal-demo/","title":"Identifying root causes of signal anomalies in a network","text":"Out[3]: <p>Unfortunately, in real world, signals are often impaired at specific frequency ranges. Causes vary: physical cable damage, water, interference, equipment failure. Interestingly, impairments tend to produce certain \"shapes\" in the FBC scans. A few of them include:</p> <ul> <li>Tilt (the signal gets linearly stronger / weaker across the spectrum)</li> <li>Wave (a periodic turbulence in the signal level)</li> <li>Suckout (a drop in a signal level in a narrow frequency range)</li> </ul> <p>Here's how that may look visually.</p> Out[4]: In\u00a0[6]: Copied! <pre>print(impaired_signals.shape)\nimpaired_signals\n</pre> print(impaired_signals.shape) impaired_signals <pre>(2000, 1000)\n</pre> Out[6]: <pre>array([[-48.73758641, -50.16252451, -50.65304196, ..., -47.68256582,\n        -51.1391094 , -50.3978072 ],\n       [-50.6824544 , -51.00383931, -49.7139957 , ..., -51.22499804,\n        -50.71977886, -50.65105806],\n       [-51.25975866, -50.38603966, -50.81908226, ..., -50.76398726,\n        -49.74155938, -51.38011933],\n       ...,\n       [-49.97342722, -50.84638163, -50.79542376, ..., -51.39005236,\n        -50.12155185, -50.53228092],\n       [-49.6501856 , -48.30615456, -49.67353999, ..., -49.78269459,\n        -49.99977493, -48.95558339],\n       [-50.2615207 , -50.18197952, -48.8535185 , ..., -50.56808448,\n        -51.07097498, -51.58680055]])</pre> In\u00a0[7]: Copied! <pre>sparse_matrix = demo.get_sparse_wavelet_matrix(impaired_signals)\nprint(f\"Number of non_zero entries: {sparse_matrix.count_nonzero()}\")\nprint(f\"Reduction in size: {(1 - (sparse_matrix.count_nonzero() / impaired_signals.size)):.4f}\")\n</pre> sparse_matrix = demo.get_sparse_wavelet_matrix(impaired_signals) print(f\"Number of non_zero entries: {sparse_matrix.count_nonzero()}\") print(f\"Reduction in size: {(1 - (sparse_matrix.count_nonzero() / impaired_signals.size)):.4f}\") <pre>Number of non_zero entries: 93220\nReduction in size: 0.9534\n</pre> <p>Let's use HDBSCAN to cluster this data. Note that it takes less than a second to run - thanks to the dimensionality reduction performed previously. We seem to have 6 clusters.</p> In\u00a0[8]: Copied! <pre>import hdbscan\nclusterer = hdbscan.HDBSCAN()\nclusterer.fit(sparse_matrix)\nprint(f\"Total clusters identified: {clusterer.labels_.max() + 1}\")\n</pre> import hdbscan clusterer = hdbscan.HDBSCAN() clusterer.fit(sparse_matrix) print(f\"Total clusters identified: {clusterer.labels_.max() + 1}\") <pre>Total clusters identified: 6\n</pre> In\u00a0[9]: Copied! <pre>from collections import Counter\nCounter(clusterer.labels_)\n</pre> from collections import Counter Counter(clusterer.labels_) Out[9]: <pre>Counter({0: 1168, 1: 543, 2: 60, 4: 152, 3: 22, 5: 53, -1: 2})</pre> <p>Next, let's visualize the signal variation in the clusters identified. It looks like HDBSCAN got quite a few things right, but notably we don't have a single \"clean signal\" cluster. It has been merged into the wave cluster (Cluster 0).</p> In\u00a0[10]: Copied! <pre>cluster_summaries  = []\n\nfor cluster in range(clusterer.labels_.max()):    \n    cluster_signals = impaired_signals[clusterer.labels_ == cluster, :]\n    cluster_summaries.append(\n        pd.DataFrame({\n            'cluster': f\"Cluster {cluster}\",\n            'avg': np.mean(cluster_signals, axis=0),\n            'max': np.max(cluster_signals, axis=0),\n            'min': np.min(cluster_signals, axis=0),\n            'Hz': x_plot_labels\n        })\n    )\n\nmelted_summaries = pd.concat(cluster_summaries).melt(['cluster', 'Hz'])\n\nalt.data_transformers.disable_max_rows()\nalt.Chart(melted_summaries).mark_line().encode(\n    alt.X(\"Hz\"), alt.Y(\"value\", title='log(dB)'), \n    alt.Color('variable', title='statistic'), alt.Row(\"cluster\")\n).properties(width=500, height=200)\n</pre> cluster_summaries  = []  for cluster in range(clusterer.labels_.max()):         cluster_signals = impaired_signals[clusterer.labels_ == cluster, :]     cluster_summaries.append(         pd.DataFrame({             'cluster': f\"Cluster {cluster}\",             'avg': np.mean(cluster_signals, axis=0),             'max': np.max(cluster_signals, axis=0),             'min': np.min(cluster_signals, axis=0),             'Hz': x_plot_labels         })     )  melted_summaries = pd.concat(cluster_summaries).melt(['cluster', 'Hz'])  alt.data_transformers.disable_max_rows() alt.Chart(melted_summaries).mark_line().encode(     alt.X(\"Hz\"), alt.Y(\"value\", title='log(dB)'),      alt.Color('variable', title='statistic'), alt.Row(\"cluster\") ).properties(width=500, height=200) Out[10]: <p>At this point, you could go back and start tuning the algorithm hyperparameters or tweak DWH process. That's a valid route to go, but an alternative is to get a human expert in the loop and explore the results. Clustering algorithms are unlikely to give a \"perfect\" answer every time, but if their results are robust enough, they are invaluable to a human expert who may be otherwise plowing through this sort of data manually.</p> In\u00a0[11]: Copied! <pre>import idendrogram\n\ncl_data = idendrogram.HDBSCANClusteringData(clusterer)\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cluster_data=cl_data)\n\nidd.create_dendrogram(truncate_mode='lastp', p=10).plot(\n    backend=\"altair\", width=600, height=300, \n    scale=\"symlog\"\n)\n</pre> import idendrogram  cl_data = idendrogram.HDBSCANClusteringData(clusterer) idd = idendrogram.idendrogram() idd.set_cluster_info(cluster_data=cl_data)  idd.create_dendrogram(truncate_mode='lastp', p=10).plot(     backend=\"altair\", width=600, height=300,      scale=\"symlog\" ) Out[11]: <p>Let's see what happens \"below\" those two subclusters. Let's plot another dendrogram, but this time go deeper. We'll plot the dendrogram on the side so it fits easier. What we can see that HDBSCAN is very certain about these subclusters - even when we go deeper, the clusters split up by one item at a time, there are no merges of larger subclusters.</p> In\u00a0[12]: Copied! <pre>idd.create_dendrogram(truncate_mode='level', p=10).plot(\n    backend=\"altair\", width=500, height=800, \n    scale=\"symlog\", orientation=\"right\"\n)\n</pre> idd.create_dendrogram(truncate_mode='level', p=10).plot(     backend=\"altair\", width=500, height=800,      scale=\"symlog\", orientation=\"right\" ) Out[12]: <p>With that in mind, let's do a couple of tweaks to the dendrogram:</p> <ul> <li>To make it more focused, let's size the radii of each node by number of items in it;</li> <li>Let's modify the tooltips to include information about variability of the signal in each node;</li> <li>Let's add information about the network segments that the nodes belong to.</li> </ul> In\u00a0[13]: Copied! <pre>def my_custom_tooltip(data, linkage_id):\n    _, nodelist = data.get_tree()\n    original_ids = nodelist[linkage_id].pre_order(lambda x: x.id)\n    signals = impaired_signals[original_ids, :]\n    network_segments = np.unique(network_clusters[original_ids])    \n    in_cluster_variability_std = np.quantile(np.std(signals, axis=0), [.25, .5, .75])\n    in_cluster_variability_min_max = np.quantile(np.max(signals, axis=0) - np.min(signals, axis=0), [.25, .5, .75])\n\n    diff_to_ideal = np.abs(signals - demo.ideal_signal.reshape(1, -1))\n\n    return {        \n        'items': str(nodelist[linkage_id].get_count()),         \n        'In-cluster variability (std)': in_cluster_variability_std.round(2).tolist(),\n        'In-cluster variability (min-max)': in_cluster_variability_min_max.round(2).tolist(),\n        'Delta to ideal signal (MAE)': diff_to_ideal.sum(axis=1).mean().round(0),\n        \"Network segments\": \", \".join([str(i) for i in network_segments]),        \n    }\n\ndendrogram = idd.create_dendrogram(\n    truncate_mode='lastp', p=10, \n    leaf_label_func = lambda *_: \"\",\n    node_hover_func= my_custom_tooltip\n)\n\nfor n in dendrogram.nodes:\n    obs_count = int(idendrogram.callbacks.counts(cl_data, n.id))\n    n.radius = max(2, np.log2(obs_count ** 2))\n\ndendrogram.plot(\n    backend=\"altair\", width=600, height=400, \n    scale=\"symlog\", orientation=\"bottom\"\n)\n</pre> def my_custom_tooltip(data, linkage_id):     _, nodelist = data.get_tree()     original_ids = nodelist[linkage_id].pre_order(lambda x: x.id)     signals = impaired_signals[original_ids, :]     network_segments = np.unique(network_clusters[original_ids])         in_cluster_variability_std = np.quantile(np.std(signals, axis=0), [.25, .5, .75])     in_cluster_variability_min_max = np.quantile(np.max(signals, axis=0) - np.min(signals, axis=0), [.25, .5, .75])      diff_to_ideal = np.abs(signals - demo.ideal_signal.reshape(1, -1))      return {                 'items': str(nodelist[linkage_id].get_count()),                  'In-cluster variability (std)': in_cluster_variability_std.round(2).tolist(),         'In-cluster variability (min-max)': in_cluster_variability_min_max.round(2).tolist(),         'Delta to ideal signal (MAE)': diff_to_ideal.sum(axis=1).mean().round(0),         \"Network segments\": \", \".join([str(i) for i in network_segments]),             }  dendrogram = idd.create_dendrogram(     truncate_mode='lastp', p=10,      leaf_label_func = lambda *_: \"\",     node_hover_func= my_custom_tooltip )  for n in dendrogram.nodes:     obs_count = int(idendrogram.callbacks.counts(cl_data, n.id))     n.radius = max(2, np.log2(obs_count ** 2))  dendrogram.plot(     backend=\"altair\", width=600, height=400,      scale=\"symlog\", orientation=\"bottom\" )  Out[13]: <p>Now it's easy to explore the dendrogram and see that cluster 2-5 all relate to the original network segments 7 &amp; 11 - that's where the tilt &amp; suckout impairment is present. Cluster 1 represents nodes affected by suckout, while Cluster 0 contained both healthy nodes and the nodes affected by the wave impairment. Going one level deeper, however, allows us to cleanly identify where the healthy nodes are. Now we can send technicians to investigate the network equipment these nodes share!</p> <p>Altair (or plotly) tooltips can be somewhat limiting though. In those cases, you may want to switch to the Streamlit component. See how these results can be displayed in Streamlit here.</p>"},{"location":"case-studies/signal-demo/#identifying-root-causes-of-signal-anomalies-in-a-network","title":"Identifying root causes of signal anomalies in a network\u00b6","text":"<p>In this notebook, idendrogram capabilities are used to illustrate how having an interactive dendrogram can useful in analysing hierarchical clustering results in a setting of detecting anomalies in a telecommunications network.</p>"},{"location":"case-studies/signal-demo/#fbc-101","title":"FBC 101\u00b6","text":"<p>Full-band-capture (FBC) is a spectrum analysis technology that allows capturing signal strength across the frequency spectrum at end-consumer devices. It is employed by telecommunications companies to remotely identify network impairment issues that may be impacting the quality of cable TV or internet for their customers. You can learn more about in a great intro post by Ron Hranac.</p> <p>Here's a quick visual introduction to FBC scans (x-axis is frequency (Hz), y-axis is signal strength (log(dB)).</p> <p>A healthy FBC scan will look something like this - with signal present at certain frequencies and no signal at others (they could be reserved for other purposes - e.g. radio or simply not used by the provider), with a bit of noise everywhere.</p>"},{"location":"case-studies/signal-demo/#identifying-root-causes-of-impairments-via-clustering","title":"Identifying root causes of impairments via clustering\u00b6","text":"<p>A telecommunications network is - well - a network. It has a hierarchical structure, and impairments that impact upstream devices likely affect downstream devices, too. As a result, what one may observe in FBC scans are clusters of similarly looking patterns. That's exactly the strategy we will employ in this notebook to identify root causes - we'll cluster FBC scans, and work with the resulting dendrograms to identify the exact network node where the issue may be.</p> <p>We use synthetically generated data in this case study. In total, we have 1000 individual nodes that fall into 12 network segments that are then connected via hierarchical structures. We'll assume that we don't have access to the data that describes the hierarchical structure of the network.</p> <p>In this hypothetical network, there are 3 sources of impairment:</p> <ul> <li>Suckout, that's affecting nodes in the segments marked '0' and '5';</li> <li>Tilt that's affecting nodes in the segments marked '7' and '11';</li> <li>Wave that is higher upstream in the network and thus affects a number of segments, including the ones affected by tilt.</li> </ul>"},{"location":"case-studies/signal-demo/#raw-data","title":"Raw data\u00b6","text":"<p>The raw data was generated previously (see the full notebook on GitHub if you're interested in the details). It is stored in a 2000 (nodes) x 1000 (signal strength at a given Hz level) numpy array.</p>"},{"location":"case-studies/signal-demo/#clustering","title":"Clustering\u00b6","text":"<p>Clustering this dataset in raw form is not the best idea: we have 1000 records, each of which has 1000 data points (i.e. 1000 dimensions). Instead, we will reduce its dimensionality using discrete wavelet transformation (DWT). I have written a practical intro to DWT a while ago in case you're interested in the details.</p> <p>DWT allows us to reduce the size of the dataset by over 95% while still maintaining most of the information about the signal structures. Yes, it sounds a bit like magic - but it isn't, it's just a perfect tool for use cases like this. Not only it reduces the dimensionality of the data, but it should also help with reducing noise in it.</p>"},{"location":"case-studies/signal-demo/#exploring-the-clustering-results","title":"Exploring the clustering results\u00b6","text":"<p>HDBSCAN identified two large clusters (Cluster 0 with 1168 members and Cluster 1 with 543 members), while the remaining ones are smaller, and there are 2 FBC scans that were deemed as anomalous.</p>"},{"location":"case-studies/signal-demo/#using-idendrogram-to-get-additional-insights","title":"Using idendrogram to get additional insights\u00b6","text":"<p>Let's start by making a quick dendrogram that visualizes the last 10 merges that happen in the hierarchical process. We can see that cluster 0 is a result of two sub-cluster merges, one of which had 890 members and the other - 278.</p>"},{"location":"case-studies/spatial-clustering/","title":"Spatial hierarchical clustering","text":"In\u00a0[2]: Copied! <pre>#filter data to cells in Vilnius with at least 100 inhabitants\nall_lithuania = gpd.read_feather(\"data.feather\")\nvilnius = all_lithuania[(all_lithuania['GYV_PAV'] == 'Vilniaus m.') &amp; (all_lithuania['POP'] &gt;= 100)].copy()\n\n#create normalized variables\nvilnius['logPop'] = np.log(vilnius['POP'])\nvilnius['logPopNorm'] = (\n    vilnius['logPop'] - vilnius['logPop'].min()\n)  / (vilnius['logPop'].max() - vilnius['logPop'].min())\nvilnius['pct_children'] = vilnius['all_00_14'].fillna(0) / vilnius['POP']\nvilnius['pct_retired'] = vilnius['all_65_plius'].fillna(0) / vilnius['POP']\nvilnius['pct_manager_specialist'] = (\n    vilnius['PRF_clerics'].fillna(0) + vilnius['PRF_managers'].fillna(0) + \n    vilnius['PRF_professionals'].fillna(0) + vilnius['OCP_employer'].fillna(0)\n) / vilnius['POP']\n\n#subset the data\ncol_names = [\n    'POP', 'logPopNorm', 'pct_children', 'pct_retired', \n    'pct_manager_specialist', 'geometry', \n]\ndata_for_clustering = vilnius[col_names].copy().reset_index(drop=True)\ndata_for_clustering.head()\n</pre> #filter data to cells in Vilnius with at least 100 inhabitants all_lithuania = gpd.read_feather(\"data.feather\") vilnius = all_lithuania[(all_lithuania['GYV_PAV'] == 'Vilniaus m.') &amp; (all_lithuania['POP'] &gt;= 100)].copy()  #create normalized variables vilnius['logPop'] = np.log(vilnius['POP']) vilnius['logPopNorm'] = (     vilnius['logPop'] - vilnius['logPop'].min() )  / (vilnius['logPop'].max() - vilnius['logPop'].min()) vilnius['pct_children'] = vilnius['all_00_14'].fillna(0) / vilnius['POP'] vilnius['pct_retired'] = vilnius['all_65_plius'].fillna(0) / vilnius['POP'] vilnius['pct_manager_specialist'] = (     vilnius['PRF_clerics'].fillna(0) + vilnius['PRF_managers'].fillna(0) +      vilnius['PRF_professionals'].fillna(0) + vilnius['OCP_employer'].fillna(0) ) / vilnius['POP']  #subset the data col_names = [     'POP', 'logPopNorm', 'pct_children', 'pct_retired',      'pct_manager_specialist', 'geometry',  ] data_for_clustering = vilnius[col_names].copy().reset_index(drop=True) data_for_clustering.head() Out[2]: POP logPopNorm pct_children pct_retired pct_manager_specialist geometry 0 106 0.025372 0.169811 0.283019 0.301887 POLYGON ((25.08982 54.66877, 25.08984 54.66967... 1 205 0.312571 0.121951 0.268293 0.268293 POLYGON ((25.08984 54.66967, 25.08987 54.67057... 2 106 0.025372 0.169811 0.226415 0.273585 POLYGON ((25.09137 54.66876, 25.09139 54.66965... 3 279 0.446772 0.146953 0.240143 0.189964 POLYGON ((25.09139 54.66965, 25.09142 54.67055... 4 118 0.072070 0.093220 0.262712 0.228814 POLYGON ((25.09142 54.67055, 25.09144 54.67145... <p>Let's visualize the data to get a feel for it. There clearly are some patterns!</p> In\u00a0[3]: Copied! <pre>layers = [    \n    pdk.Layer(\n        \"GeoJsonLayer\",\n        data=data_for_clustering,    \n        get_fill_color=\"\"\"\n            [255 * (1 - pct_retired), \n            255* (1 - pct_manager_specialist), \n            255* (1 - pct_children)\n        ]\"\"\",\n        pickable=True,\n        auto_highlight = True,\n    ),\n]\n\npdk.Deck(\n    layers,\n    tooltip=True,\n    initial_view_state=pdk.ViewState(\n        longitude=25.25,\n        latitude=54.7,\n        zoom=10,\n        min_zoom=9,\n        max_zoom=15,    \n    )\n).to_html(iframe_width=720)\n</pre> layers = [         pdk.Layer(         \"GeoJsonLayer\",         data=data_for_clustering,             get_fill_color=\"\"\"             [255 * (1 - pct_retired),              255* (1 - pct_manager_specialist),              255* (1 - pct_children)         ]\"\"\",         pickable=True,         auto_highlight = True,     ), ]  pdk.Deck(     layers,     tooltip=True,     initial_view_state=pdk.ViewState(         longitude=25.25,         latitude=54.7,         zoom=10,         min_zoom=9,         max_zoom=15,         ) ).to_html(iframe_width=720) Out[3]: <p>Before we proceed with clustering, we need a connectivity matrix - an additional input that spatially constrained algorithms require so that they only merge adjacents nodes. The dataset also needs to be fully connected - i.e. it should be possible to form a single cluster from it. As seen on the map, this dataset does not represent a continuous grid, so we need to be a bit creative to produce a connectivity matrix that makes it fully connected.</p> <p>The below code achieves that by finding at least 4 nearest neighbours in each of the 8-directions (vertical, horizontal and diagonal) for each of the cells, iterating from 1 cell away up to 100 cells away.</p> In\u00a0[4]: Copied! <pre>compute_connectivity_matrix = False\n#projection to equal area CRS to obtain more accurate centroids\nprojected_data = data_for_clustering.to_crs('+proj=cea')\n\n#create the connectivity matrix \n# (otherwise load a stored one)\nif compute_connectivity_matrix:\n    \n    #dict to store the 8 neighbours\n    nbh_template = {}\n    for k in list(permutations([-1, 0, 1], 2)) + [(1,1), (-1, -1)]:\n        nbh_template[k] = None\n        \n    connected = []\n\n    #iterate through the dataset\n    for x in tqdm(projected_data.itertuples(index=True), total=len(projected_data)):\n        point = x.geometry.centroid\n        neighbours = nbh_template.copy()\n        #iterate from 1 to 100 cells away\n        for i in range(1, 100):\n            for (x_offset, y_offset), val in neighbours.items():        \n                if val is None:\n                    #determine neighbour coordinates (hack-ish way, not 100% accurate)\n                    neighbour_point = Point(\n                        point.x + i * 165 * x_offset, \n                        point.y + i * 55 * y_offset\n                    )\n                    p_offset = gpd.GeoSeries(\n                        [neighbour_point], \n                        crs='+proj=cea'\n                    ).to_crs(data_for_clustering.crs)\n\n                    #see if it actually exists in the dataset, save if yes                    \n                    indexes = projected_data.centroid.to_crs(\n                        data_for_clustering.crs\n                    ).geom_almost_equals(p_offset[0], decimal=3)\n                    found = projected_data.index[indexes].tolist()\n                if found:\n                    neighbours[x_offset, y_offset] = found[0]\n\n            #stop after at least 4 neighbours are found\n            if len([v for v in neighbours.values() if v is not None]) &gt;= 4:\n                break\n        \n        #save in a sparse COO format    \n        for n in set(neighbours.values()): \n            if n:       \n                connected.append((x.Index, n, 1))\n                connected.append((n, x.Index, 1))\n    \n    np.save(\"connectivity_matrix\", np.array(connected))\nelse:\n    connected = np.load(\"connectivity_matrix.npy\", allow_pickle=True)\n</pre> compute_connectivity_matrix = False #projection to equal area CRS to obtain more accurate centroids projected_data = data_for_clustering.to_crs('+proj=cea')  #create the connectivity matrix  # (otherwise load a stored one) if compute_connectivity_matrix:          #dict to store the 8 neighbours     nbh_template = {}     for k in list(permutations([-1, 0, 1], 2)) + [(1,1), (-1, -1)]:         nbh_template[k] = None              connected = []      #iterate through the dataset     for x in tqdm(projected_data.itertuples(index=True), total=len(projected_data)):         point = x.geometry.centroid         neighbours = nbh_template.copy()         #iterate from 1 to 100 cells away         for i in range(1, 100):             for (x_offset, y_offset), val in neighbours.items():                         if val is None:                     #determine neighbour coordinates (hack-ish way, not 100% accurate)                     neighbour_point = Point(                         point.x + i * 165 * x_offset,                          point.y + i * 55 * y_offset                     )                     p_offset = gpd.GeoSeries(                         [neighbour_point],                          crs='+proj=cea'                     ).to_crs(data_for_clustering.crs)                      #see if it actually exists in the dataset, save if yes                                         indexes = projected_data.centroid.to_crs(                         data_for_clustering.crs                     ).geom_almost_equals(p_offset[0], decimal=3)                     found = projected_data.index[indexes].tolist()                 if found:                     neighbours[x_offset, y_offset] = found[0]              #stop after at least 4 neighbours are found             if len([v for v in neighbours.values() if v is not None]) &gt;= 4:                 break                  #save in a sparse COO format             for n in set(neighbours.values()):              if n:                        connected.append((x.Index, n, 1))                 connected.append((n, x.Index, 1))          np.save(\"connectivity_matrix\", np.array(connected)) else:     connected = np.load(\"connectivity_matrix.npy\", allow_pickle=True) <p>How do we know if the dataset is now fully connected? One of the approaches is to analyze the Laplacian matrix of the dataset. If the second smallest eigenvalue of it is positive, the dataset represents a fully connected graph.</p> In\u00a0[5]: Copied! <pre>#create a sparse adjacency matrix\ni, j, data = zip(*connected)\nconnectivity_matrix = coo_array((data, (i, j)))\n\n#form laplacian matrix L\nD = connectivity_matrix.sum(axis=0)\nL = np.diag(D) - connectivity_matrix\n\n#check if 2nd eigenvalue is positive\nev = np.sort(eigvalsh(L))\nprint(ev[1] &gt; 0)\n</pre> #create a sparse adjacency matrix i, j, data = zip(*connected) connectivity_matrix = coo_array((data, (i, j)))  #form laplacian matrix L D = connectivity_matrix.sum(axis=0) L = np.diag(D) - connectivity_matrix  #check if 2nd eigenvalue is positive ev = np.sort(eigvalsh(L)) print(ev[1] &gt; 0) <pre>True\n</pre> <p>The Laplacian matrix tells us more about the underlying spatial structure of the dataset. My (non-robust) understanding is that low eigenvalues represent individual sub-components of the graph. As a result, one can apply an \"elbow\" criteria, similar to one applied when determining the number of clusters in k-means algorithm, to identify a number of spatial sub-graphs in the dataset.</p> <p>In this case, looks like we don't really have strongly connected sub-clusters - which is not surprising, given its mostly a continuous grid over a city.</p> In\u00a0[6]: Copied! <pre>alt.Chart(\n    pd.DataFrame({'eigenvalue': ev[:30], 'index': range(30)})\n).mark_line().encode(x='index', y='eigenvalue').properties(\n    title='50 smallest eigenvalues of graph Laplacian',\n    width=600,\n    height=200\n)\n</pre> alt.Chart(     pd.DataFrame({'eigenvalue': ev[:30], 'index': range(30)}) ).mark_line().encode(x='index', y='eigenvalue').properties(     title='50 smallest eigenvalues of graph Laplacian',     width=600,     height=200 ) Out[6]: <p>Before we go ahead with the actual clustering, let's add the (normalized) latitude and longitude to the dataset, too. Because the connectivity matrix sometimes indicates connectivity between far-away cells (due to gaps in the grid), having coordinates as a dimension will force the clustering algorithm not to merge two further-apart nodes unless \"absolutely necessary\". To force it, the values are normalized to range of 0-5, making them 5x as important as the other dimensions (which are all normalized to 0-1 scale).</p> In\u00a0[7]: Copied! <pre>importance = 5\ndata_for_clustering['x'] = (projected_data.centroid.x - projected_data.centroid.x.min()) / (\n    projected_data.centroid.x.max() - projected_data.centroid.x.min()\n) * importance\ndata_for_clustering['y'] = (projected_data.centroid.y - projected_data.centroid.y.min()) / (\n    projected_data.centroid.y.max() - projected_data.centroid.y.min()\n) * importance\n</pre> importance = 5 data_for_clustering['x'] = (projected_data.centroid.x - projected_data.centroid.x.min()) / (     projected_data.centroid.x.max() - projected_data.centroid.x.min() ) * importance data_for_clustering['y'] = (projected_data.centroid.y - projected_data.centroid.y.min()) / (     projected_data.centroid.y.max() - projected_data.centroid.y.min() ) * importance <p>Now we can go ahead with clustering.</p> In\u00a0[8]: Copied! <pre>model = AgglomerativeClustering(\n    n_clusters=10, metric=\"l2\", \n    connectivity=connectivity_matrix, \n    linkage=\"complete\", \n    compute_distances=True,\n    compute_full_tree=True,    \n)\n\ncol_names = [\n    #'logPopNorm', \n    'x', 'y',\n     'pct_children', \n     'pct_retired',          \n    'pct_manager_specialist',     \n]\n\nmodel.fit(data_for_clustering[col_names])\ncl_data = idendrogram.ScikitLearnClusteringData(model)\n</pre> model = AgglomerativeClustering(     n_clusters=10, metric=\"l2\",      connectivity=connectivity_matrix,      linkage=\"complete\",      compute_distances=True,     compute_full_tree=True,     )  col_names = [     #'logPopNorm',      'x', 'y',      'pct_children',       'pct_retired',               'pct_manager_specialist',      ]  model.fit(data_for_clustering[col_names]) cl_data = idendrogram.ScikitLearnClusteringData(model) <p>Let's see what are the clusters that were produced (I'm excluding any smaller clusters that have &lt; 1000 inhabitants). A couple of smaller towns that are in the outskirts of Vilnius (and technically belong to them) formed their own independent clusters. Whereas Vilnius \"proper\", got separated into 3 large clusters - the west side, the north-east, and the center.</p> In\u00a0[9]: Copied! <pre>data_for_clustering['cluster'] = model.labels_\nrel_clusters = np.where(data_for_clustering.groupby('cluster')['POP'].sum() &gt; 1_000)[0]\ncolors = [\n    '#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99',\n    '#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99'\n]\n\ncolor_map = {k: list(int(v.lstrip(\"#\")[i:i+2], 16) \n    for i in (0, 2, 4)) for k,v in zip(rel_clusters, colors)}\n\nto_plot = data_for_clustering[data_for_clustering['cluster'].isin(rel_clusters)].copy()\nto_plot['color'] = to_plot['cluster'].apply(lambda x: color_map[x])\nlayers = [    \n    pdk.Layer(\n        \"GeoJsonLayer\",\n        data=to_plot.reset_index(names='foo'),\n        get_fill_color=\"color\",\n        pickable=True,\n        auto_highlight = True,\n    ),\n]\n\npdk.Deck(\n    layers,\n    tooltip=True,\n    initial_view_state=pdk.ViewState(\n        longitude=25.25,\n        latitude=54.7,\n        zoom=10,\n        min_zoom=5,\n        max_zoom=15,    \n    )\n).to_html(iframe_width=720)\n</pre> data_for_clustering['cluster'] = model.labels_ rel_clusters = np.where(data_for_clustering.groupby('cluster')['POP'].sum() &gt; 1_000)[0] colors = [     '#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99',     '#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99' ]  color_map = {k: list(int(v.lstrip(\"#\")[i:i+2], 16)      for i in (0, 2, 4)) for k,v in zip(rel_clusters, colors)}  to_plot = data_for_clustering[data_for_clustering['cluster'].isin(rel_clusters)].copy() to_plot['color'] = to_plot['cluster'].apply(lambda x: color_map[x]) layers = [         pdk.Layer(         \"GeoJsonLayer\",         data=to_plot.reset_index(names='foo'),         get_fill_color=\"color\",         pickable=True,         auto_highlight = True,     ), ]  pdk.Deck(     layers,     tooltip=True,     initial_view_state=pdk.ViewState(         longitude=25.25,         latitude=54.7,         zoom=10,         min_zoom=5,         max_zoom=15,         ) ).to_html(iframe_width=720) Out[9]: <p>What about the demographic differences between these clusters? Looks like:</p> <ul> <li>North-east has more retired folks &amp; high-earners, and noticeable less children;</li> <li>West side has less high earners;</li> <li>Center is somewhere in between the two clusters.</li> </ul> <p>Not particularly exciting findings \ud83e\udd14.</p> In\u00a0[10]: Copied! <pre>def calculate_stats(df):\n    return pd.DataFrame([{\n        'pct_manager_specialist':  (df['POP'] * df['pct_manager_specialist']).sum() / (df['POP']).sum(),\n        'pct_children':  (df['POP'] * df['pct_children']).sum() / (df['POP']).sum(),\n        'pct_retired':  (df['POP'] * df['pct_retired']).sum() / (df['POP']).sum(),        \n    }]).round(2)\n\ntop3_clusters = data_for_clustering[data_for_clustering['cluster'].isin([0,1,2])].copy()\ntop3_clusters['cluster_name'] = top3_clusters['cluster'].apply(\n    lambda i: {0: 'center', 1: 'north-east', 2: 'west'}[i]\n)\ntop3_clusters.groupby('cluster_name').apply(\n    calculate_stats\n).reset_index().drop('level_1', axis=1)\n</pre> def calculate_stats(df):     return pd.DataFrame([{         'pct_manager_specialist':  (df['POP'] * df['pct_manager_specialist']).sum() / (df['POP']).sum(),         'pct_children':  (df['POP'] * df['pct_children']).sum() / (df['POP']).sum(),         'pct_retired':  (df['POP'] * df['pct_retired']).sum() / (df['POP']).sum(),             }]).round(2)  top3_clusters = data_for_clustering[data_for_clustering['cluster'].isin([0,1,2])].copy() top3_clusters['cluster_name'] = top3_clusters['cluster'].apply(     lambda i: {0: 'center', 1: 'north-east', 2: 'west'}[i] ) top3_clusters.groupby('cluster_name').apply(     calculate_stats ).reset_index().drop('level_1', axis=1) Out[10]: cluster_name pct_manager_specialist pct_children pct_retired 0 center 0.36 0.17 0.17 1 north-east 0.36 0.15 0.22 2 west 0.31 0.17 0.19 <p>Perhaps the issue is that these clusters are too homogenous and they should be broken out. We can use <code>idendrogram</code> for that. We'll make a couple of customizations:</p> <ul> <li>Customize the tooltip to include difference of (weighted) average of the demographic variables of interest from the city average;</li> <li>Change the size of nodes to represent population, but only for leaf nodes and the cluster-level nodes;</li> <li>Tweak the colors for super/sub-clusters to reduce amount of noise in the visualization.</li> </ul> In\u00a0[11]: Copied! <pre>#setup idendrogram objects\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\n\n\n#custom tooltip functions\ndef my_tooltip(data, linkage_id):\n\n    #get all original observation IDs that roll up to this node\n    _, nodelist = data.get_tree()\n    original_ids = nodelist[linkage_id].pre_order(lambda x: x.id)\n\n    #get the associated dataframe rows\n    cells = data_for_clustering.loc[original_ids, :]\n\n    #form basic tooltip with total population &amp; number of leaf nodes\n    tooltip = {        \n        'number of cells': str(nodelist[linkage_id].get_count()),           \n        'Total Population':  int(cells['POP'].values.sum()),                \n    }\n\n    #calculate weighted average KPIs for this node\n    for var in col_names[2:]:\n        pct = (cells[var] * cells['POP']).sum() / cells['POP'].sum()\n        ref = (\n            data_for_clustering[var] * data_for_clustering['POP']\n        ).sum() / data_for_clustering['POP'].sum()\n        tooltip[var] = str(int(round(pct - ref,2) * 100)) + '%'\n\n    return tooltip\n\n# create a dendrogram using a custom tooltip\n# use empty leaf node axis labels\n# use a custom color scheme that corresponds to colors in the map chart above\ndendrogram = idd.create_dendrogram(\n    truncate_mode='lastp', p=30, \n    node_hover_func=my_tooltip, \n    leaf_label_func= lambda *x: \"\",\n    link_color_func=idendrogram.callbacks.link_painter(\n        colors = {k: v for k,v in zip(rel_clusters, colors)},\n        above_threshold='grey'\n    )\n)\n\n#iterate through the nodes and change their radius based on population\nfor n in dendrogram.nodes:\n    _, nodelist = cl_data.get_tree()\n    original_ids = nodelist[n.id].pre_order(lambda x: x.id)\n\n    population = data_for_clustering.loc[original_ids, 'POP'].sum()    \n    if n.type not in ['subcluster', 'supercluster']:\n        n.radius = np.sqrt(population / 1000) * 1.2\n    else:\n        n.radius = 2    \n\n#plot!\ndendrogram.plot(\n    backend='altair',\n    width=620,    \n    orientation=\"bottom\"                \n)\n</pre> #setup idendrogram objects idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data)   #custom tooltip functions def my_tooltip(data, linkage_id):      #get all original observation IDs that roll up to this node     _, nodelist = data.get_tree()     original_ids = nodelist[linkage_id].pre_order(lambda x: x.id)      #get the associated dataframe rows     cells = data_for_clustering.loc[original_ids, :]      #form basic tooltip with total population &amp; number of leaf nodes     tooltip = {                 'number of cells': str(nodelist[linkage_id].get_count()),                    'Total Population':  int(cells['POP'].values.sum()),                     }      #calculate weighted average KPIs for this node     for var in col_names[2:]:         pct = (cells[var] * cells['POP']).sum() / cells['POP'].sum()         ref = (             data_for_clustering[var] * data_for_clustering['POP']         ).sum() / data_for_clustering['POP'].sum()         tooltip[var] = str(int(round(pct - ref,2) * 100)) + '%'      return tooltip  # create a dendrogram using a custom tooltip # use empty leaf node axis labels # use a custom color scheme that corresponds to colors in the map chart above dendrogram = idd.create_dendrogram(     truncate_mode='lastp', p=30,      node_hover_func=my_tooltip,      leaf_label_func= lambda *x: \"\",     link_color_func=idendrogram.callbacks.link_painter(         colors = {k: v for k,v in zip(rel_clusters, colors)},         above_threshold='grey'     ) )  #iterate through the nodes and change their radius based on population for n in dendrogram.nodes:     _, nodelist = cl_data.get_tree()     original_ids = nodelist[n.id].pre_order(lambda x: x.id)      population = data_for_clustering.loc[original_ids, 'POP'].sum()         if n.type not in ['subcluster', 'supercluster']:         n.radius = np.sqrt(population / 1000) * 1.2     else:         n.radius = 2      #plot! dendrogram.plot(     backend='altair',     width=620,         orientation=\"bottom\"                 ) Out[11]: <p>We immediately see a couple of interesting observations:</p> <ul> <li>Cluster 1 (North-East) is largely one cluster at this level of cut-off.</li> <li>Cluster 2 (West) has at least two large subclusters that are very different (one of them seems to be \"young professional families with children\", the other - \"a higher share of retired population with less professional workers\")</li> <li>Cluster 3 (Center) has three larger subclusters, though the diferences between them are smaller than in cluster 2.</li> </ul> <p>At this point, you may be wondering - could we display \"sub-dendrograms\" for each of the clusters? That is what would be really interesting to explore. The answer is - yes, we can. It's a bit more work, but definitely possible.</p> <p>Here's how we could go about it.</p> <p>First, let's iterate through all the nodes and select all the ones that are not \"super-clusters\". Save them into a dictionary with a separate key for each cluster.</p> In\u00a0[12]: Copied! <pre>from collections import defaultdict\nclusters = defaultdict(lambda: {'nodes': [], 'links': []})\n\n#create another dendrogram that goes deeper\ndendrogram = idd.create_dendrogram(\n    truncate_mode='lastp', p=100, \n    node_hover_func=my_tooltip, \n    leaf_label_func= lambda *x: \"\",\n    link_color_func=idendrogram.callbacks.link_painter(\n        colors = {k: v for k,v in zip(rel_clusters, colors)},\n        above_threshold='grey'\n    )\n)\n\n#adjust radius\nfor n in dendrogram.nodes:\n    _, nodelist = cl_data.get_tree()\n    original_ids = nodelist[n.id].pre_order(lambda x: x.id)\n\n    population = data_for_clustering.loc[original_ids, 'POP'].sum()        \n    n.radius = np.sqrt(population / 1000) * 0.5   \n    n.fillcolor = n.edgecolor\n\nselected_node_ids = []\n\n#iterate through the nodes and save them to appropriate sub-lists based on cluster assignment\nfor n in dendrogram.nodes:\n    if n.type != 'supercluster':\n        _, nodelist = cl_data.get_tree()\n        #find first leaf node\n        original_id = nodelist[n.id].pre_order(lambda x: x.id)[0]\n        #obtain cluster label\n        cluster = data_for_clustering.loc[original_id, 'cluster']\n        #save this node to the right key in the main dictionary\n        clusters[cluster]['nodes'].append(n)\n        #also save the node ID to a list - we'll need it for finding links\n        selected_node_ids.append(n.id)\n</pre> from collections import defaultdict clusters = defaultdict(lambda: {'nodes': [], 'links': []})  #create another dendrogram that goes deeper dendrogram = idd.create_dendrogram(     truncate_mode='lastp', p=100,      node_hover_func=my_tooltip,      leaf_label_func= lambda *x: \"\",     link_color_func=idendrogram.callbacks.link_painter(         colors = {k: v for k,v in zip(rel_clusters, colors)},         above_threshold='grey'     ) )  #adjust radius for n in dendrogram.nodes:     _, nodelist = cl_data.get_tree()     original_ids = nodelist[n.id].pre_order(lambda x: x.id)      population = data_for_clustering.loc[original_ids, 'POP'].sum()             n.radius = np.sqrt(population / 1000) * 0.5        n.fillcolor = n.edgecolor  selected_node_ids = []  #iterate through the nodes and save them to appropriate sub-lists based on cluster assignment for n in dendrogram.nodes:     if n.type != 'supercluster':         _, nodelist = cl_data.get_tree()         #find first leaf node         original_id = nodelist[n.id].pre_order(lambda x: x.id)[0]         #obtain cluster label         cluster = data_for_clustering.loc[original_id, 'cluster']         #save this node to the right key in the main dictionary         clusters[cluster]['nodes'].append(n)         #also save the node ID to a list - we'll need it for finding links         selected_node_ids.append(n.id) <p>Then, we have to do the same with links. First, we find the links that relate to nodes of interest, and then place them into appropriate lists, too.</p> In\u00a0[13]: Copied! <pre>#find links that connect nodes of interest (skip any links that link to super clusters)\nselected_links = [l for l in dendrogram.links \n    if (l.children_id[0] in selected_node_ids or l.children_id[1] in selected_node_ids) \n    and l.id in selected_node_ids\n]\n\n#iterate through the links and place them into the right dictionary keys\nfor l in selected_links:\n    _, nodelist = cl_data.get_tree()\n    original_id = nodelist[l.id].pre_order(lambda x: x.id)[0]\n    cluster = data_for_clustering.loc[original_id, 'cluster']\n    clusters[cluster]['links'].append(l)\n</pre> #find links that connect nodes of interest (skip any links that link to super clusters) selected_links = [l for l in dendrogram.links      if (l.children_id[0] in selected_node_ids or l.children_id[1] in selected_node_ids)      and l.id in selected_node_ids ]  #iterate through the links and place them into the right dictionary keys for l in selected_links:     _, nodelist = cl_data.get_tree()     original_id = nodelist[l.id].pre_order(lambda x: x.id)[0]     cluster = data_for_clustering.loc[original_id, 'cluster']     clusters[cluster]['links'].append(l) <p>Finally, we are ready to produce sub-dendrograms. To do that, we will instantiate <code>idendrogram.Dendrogram</code> objects manually with the relevant node/link lists. To get axis labels / chart widths, we need to also correctly set max/min coordinates of each dendrogram.</p> In\u00a0[14]: Copied! <pre>#list to keep the subdendrogram charts\ncharts = []\n\n#iterate through dictionary of all the node/link data\nfor cluster_id, vals in clusters.items():\n    if len(vals['links']) and cluster_id in [0,1,2]:\n\n        # for plotting purposes, we need to know min/max X and Y coordinates\n        # we can obtain that from links list\n        x_coord, y_coord = zip(*[(l.x, l.y) for l in vals['links']])\n        min_x = np.array(x_coord).flatten().min()\n        max_x = np.array(x_coord).flatten().max()\n        min_y = np.array(y_coord).flatten().min()\n        max_y = np.array(y_coord).flatten().max()\n\n        # picking up axis labels (blank in this case - just for completeness)\n        relevant_labels = [a for a in dendrogram.axis_labels if a.x &gt;= min_x and a.x &lt;= max_x]\n\n        # forming a dendrogram object manually\n        cluster_dendrogram = idendrogram.Dendrogram(\n            links = vals['links'],\n            nodes = vals['nodes'],\n            x_domain= (min_x, max_x),\n            y_domain= (min_y, max_y),\n            axis_labels= relevant_labels,\n            computed_nodes= True\n        )\n\n        #making a plot\n        c = cluster_dendrogram.plot(\n            backend='altair',\n            width=180, height=20 * len(vals['links']),\n            scale='symlog',\n            orientation=\"right\",            \n        )\n\n        #setting manual scale adjustments to make it look better\n        c['layer'][0]['encoding']['x']['scale'] = alt.Scale(\n            reverse=True, domain=[0, 1.3], clamp=True, type='pow', exponent=2\n        )\n        c['layer'][0]['encoding']['y']['scale'] = alt.Scale(zero=False)\n\n        #saving\n        charts.append(c)\n</pre> #list to keep the subdendrogram charts charts = []  #iterate through dictionary of all the node/link data for cluster_id, vals in clusters.items():     if len(vals['links']) and cluster_id in [0,1,2]:          # for plotting purposes, we need to know min/max X and Y coordinates         # we can obtain that from links list         x_coord, y_coord = zip(*[(l.x, l.y) for l in vals['links']])         min_x = np.array(x_coord).flatten().min()         max_x = np.array(x_coord).flatten().max()         min_y = np.array(y_coord).flatten().min()         max_y = np.array(y_coord).flatten().max()          # picking up axis labels (blank in this case - just for completeness)         relevant_labels = [a for a in dendrogram.axis_labels if a.x &gt;= min_x and a.x &lt;= max_x]          # forming a dendrogram object manually         cluster_dendrogram = idendrogram.Dendrogram(             links = vals['links'],             nodes = vals['nodes'],             x_domain= (min_x, max_x),             y_domain= (min_y, max_y),             axis_labels= relevant_labels,             computed_nodes= True         )          #making a plot         c = cluster_dendrogram.plot(             backend='altair',             width=180, height=20 * len(vals['links']),             scale='symlog',             orientation=\"right\",                     )          #setting manual scale adjustments to make it look better         c['layer'][0]['encoding']['x']['scale'] = alt.Scale(             reverse=True, domain=[0, 1.3], clamp=True, type='pow', exponent=2         )         c['layer'][0]['encoding']['y']['scale'] = alt.Scale(zero=False)          #saving         charts.append(c) <p>Now, we are ready to plot and explore. Of course, it would be even better if we could see these nodes on the map. For that, check out the Streamlit demo!</p> In\u00a0[15]: Copied! <pre>#plot!\nalt.hconcat(*charts)\n</pre> #plot! alt.hconcat(*charts) Out[15]:"},{"location":"case-studies/spatial-clustering/#spatial-hierarchical-clustering","title":"Spatial hierarchical clustering\u00b6","text":"<p>This notebook presents a case study of clustering geographical information - cells of a 100mx100m grid with demographical information from Vilnius, Lithuania. We will employ spatially constrained hierarchical clustering - a form of hierarchical clustering that ensures that clusters are only formed from adjacent geographical units.</p> <p>Then, <code>idendrogram</code> will be used to visualize the resulting hierarchies, with examples how dendrograms can be created to visualize only part of the dataset (e.g. dendrogram per cluster).</p> <p>To make it simple, we will use just a few demographical attributes from the data:</p> <ul> <li>population (log-scaled and normalized)</li> <li>% inhabitants that are retired</li> <li>% inhabitants that are children</li> <li>% inhabitants that are employed in high-earning positions</li> </ul>"},{"location":"guides/custom-attributes/","title":"Customizing other attributes","text":"In\u00a0[3]: Copied! <pre>from idendrogram.containers import AxisLabel, ClusterLink, ClusterNode\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass MyAxisLabel(AxisLabel):\n    labelAngle: int = -180\n\n@dataclass\nclass MyNode(ClusterNode):\n    radius: float = 5\n    _default_leaf_radius: float = 10    \n\n@dataclass\nclass Mylink(ClusterLink):\n    strokewidth: float = 0.5\n    strokedash: list = field(default_factory=lambda: [6, 2])\n    \nidd = idendrogram.idendrogram(\n    axis_label_factory=lambda x:  MyAxisLabel(**x),\n    node_factory= lambda x: MyNode(**x),\n    link_factory= lambda x: Mylink(**x))\n\nidd.set_cluster_info(cl_data)\ndendrogram = idd.create_dendrogram()\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> from idendrogram.containers import AxisLabel, ClusterLink, ClusterNode from dataclasses import dataclass, field  @dataclass class MyAxisLabel(AxisLabel):     labelAngle: int = -180  @dataclass class MyNode(ClusterNode):     radius: float = 5     _default_leaf_radius: float = 10      @dataclass class Mylink(ClusterLink):     strokewidth: float = 0.5     strokedash: list = field(default_factory=lambda: [6, 2])      idd = idendrogram.idendrogram(     axis_label_factory=lambda x:  MyAxisLabel(**x),     node_factory= lambda x: MyNode(**x),     link_factory= lambda x: Mylink(**x))  idd.set_cluster_info(cl_data) dendrogram = idd.create_dendrogram() to_altair(dendrogram=dendrogram, height=200, width=629) Out[3]: In\u00a0[4]: Copied! <pre>idd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\ndendrogram = idd.create_dendrogram()\n\nfor n in dendrogram.nodes:\n    obs_count = int(idendrogram.callbacks.counts(cl_data, n.id))\n    n.radius = obs_count / 10\n\n\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data) dendrogram = idd.create_dendrogram()  for n in dendrogram.nodes:     obs_count = int(idendrogram.callbacks.counts(cl_data, n.id))     n.radius = obs_count / 10   to_altair(dendrogram=dendrogram, height=200, width=629) Out[4]:"},{"location":"guides/custom-attributes/#customizing-other-attributes","title":"Customizing other attributes\u00b6","text":""},{"location":"guides/custom-attributes/#changing-default-values","title":"Changing default values\u00b6","text":"<p>Default link, node and axis label values can be changed by providing customized data classes to idendrogram constructor. For a full list of properties of each data class, see Data Containers.</p>"},{"location":"guides/custom-attributes/#postprocessing","title":"Postprocessing\u00b6","text":"<p>Any attribute of a node or a link can also be adjusted after the dendrogram object has been created. Here's an example where radii of nodes are adjusted based on number of observations they represent.</p>"},{"location":"guides/custom-colors/","title":"Customizing colors","text":"In\u00a0[3]: Copied! <pre>#instantiate idendrogram object and pass clustering data\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\n\n#mapping from linkage_id to hex format color string \n# using an arbitrary id -&gt; rbg mapping\nnode_painter = lambda _, linkage_id: '#{:02x}{:02x}{:02x}'.format(\n    linkage_id % 255, \n    (linkage_id * linkage_id) % 255,  \n    linkage_id % 3 * linkage_id % 10\n)\n\n#create a dendrogram object\ndendrogram = idd.create_dendrogram(link_color_func=node_painter)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> #instantiate idendrogram object and pass clustering data idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data)  #mapping from linkage_id to hex format color string  # using an arbitrary id -&gt; rbg mapping node_painter = lambda _, linkage_id: '#{:02x}{:02x}{:02x}'.format(     linkage_id % 255,      (linkage_id * linkage_id) % 255,       linkage_id % 3 * linkage_id % 10 )  #create a dendrogram object dendrogram = idd.create_dendrogram(link_color_func=node_painter) to_altair(dendrogram=dendrogram, height=200, width=629) Out[3]: In\u00a0[4]: Copied! <pre>cluster_painter = idendrogram.callbacks.link_painter(\n    colors={\n        1: 'red',\n        2: 'blue',\n        3: 'green',\n    }, \n    above_threshold='black'\n)\n</pre> cluster_painter = idendrogram.callbacks.link_painter(     colors={         1: 'red',         2: 'blue',         3: 'green',     },      above_threshold='black' ) In\u00a0[5]: Copied! <pre>#create a dendrogram object\ndendrogram = idd.create_dendrogram(link_color_func=cluster_painter)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> #create a dendrogram object dendrogram = idd.create_dendrogram(link_color_func=cluster_painter) to_altair(dendrogram=dendrogram, height=200, width=629) Out[5]: In\u00a0[6]: Copied! <pre>from idendrogram.containers import ClusterNode\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyNode(ClusterNode):\n    labelcolor: str = 'pink'\n    edgecolor: str = 'orange'\n    fillcolor: str = 'yellow'\n\nidd = idendrogram.idendrogram(node_factory=lambda x:  MyNode(**x))\nidd.set_cluster_info(cl_data)\n\n# make nodes black-ish otherwise\nnode_painter = lambda _, linkage_id: '#{:02x}{:02x}{:02x}'.format(\n    0, \n    0,\n    (linkage_id) % 255,  \n)\n\n#create a dendrogram object\ndendrogram = idd.create_dendrogram(link_color_func=node_painter)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> from idendrogram.containers import ClusterNode from dataclasses import dataclass  @dataclass class MyNode(ClusterNode):     labelcolor: str = 'pink'     edgecolor: str = 'orange'     fillcolor: str = 'yellow'  idd = idendrogram.idendrogram(node_factory=lambda x:  MyNode(**x)) idd.set_cluster_info(cl_data)  # make nodes black-ish otherwise node_painter = lambda _, linkage_id: '#{:02x}{:02x}{:02x}'.format(     0,      0,     (linkage_id) % 255,   )  #create a dendrogram object dendrogram = idd.create_dendrogram(link_color_func=node_painter) to_altair(dendrogram=dendrogram, height=200, width=629) Out[6]: In\u00a0[7]: Copied! <pre>@dataclass\nclass MonochromeNode(ClusterNode):\n    labelcolor: str = 'white'\n    edgecolor: str = 'grey'\n    fillcolor: str = 'grey'\n\nidd = idendrogram.idendrogram(node_factory=lambda x:  MonochromeNode(**x))\nidd.set_cluster_info(cl_data)\n\n# make nodes black-ish otherwise\ngrey_painter = lambda _, __: \"grey\"\n\n#create a dendrogram object\ndendrogram = idd.create_dendrogram(link_color_func=grey_painter)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre>  @dataclass class MonochromeNode(ClusterNode):     labelcolor: str = 'white'     edgecolor: str = 'grey'     fillcolor: str = 'grey'  idd = idendrogram.idendrogram(node_factory=lambda x:  MonochromeNode(**x)) idd.set_cluster_info(cl_data)  # make nodes black-ish otherwise grey_painter = lambda _, __: \"grey\"  #create a dendrogram object dendrogram = idd.create_dendrogram(link_color_func=grey_painter) to_altair(dendrogram=dendrogram, height=200, width=629) Out[7]: In\u00a0[8]: Copied! <pre>dendrogram = idd.create_dendrogram()\nfor i, n in enumerate(dendrogram.nodes):\n    if i % 2 == 0:\n        n.edgecolor = 'red'\n        n.fillcolor = 'red'\n        n.labelcolor = 'lightgrey'\n    else:       \n        n.edgecolor = 'lightgrey'\n        n.fillcolor = 'lightgrey'\n        n.labelcolor = 'red'\nfor i, l in enumerate(dendrogram.links):\n    if i % 2 == 0:\n        l.fillcolor = 'blue'        \n    else:       \n        l.fillcolor = 'green'\n\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> dendrogram = idd.create_dendrogram() for i, n in enumerate(dendrogram.nodes):     if i % 2 == 0:         n.edgecolor = 'red'         n.fillcolor = 'red'         n.labelcolor = 'lightgrey'     else:                n.edgecolor = 'lightgrey'         n.fillcolor = 'lightgrey'         n.labelcolor = 'red' for i, l in enumerate(dendrogram.links):     if i % 2 == 0:         l.fillcolor = 'blue'             else:                l.fillcolor = 'green'  to_altair(dendrogram=dendrogram, height=200, width=629) Out[8]:"},{"location":"guides/custom-colors/#customizing-colors","title":"Customizing colors\u00b6","text":""},{"location":"guides/custom-colors/#using-link_color_func","title":"Using <code>link_color_func</code>\u00b6","text":""},{"location":"guides/custom-colors/#coloring-based-on-linkage-id","title":"Coloring based on linkage ID\u00b6","text":"<p>Colors are controlled via <code>link_color_func</code> parameter of  <code>idd.create_dendrogram</code> function. To customize colors, pass a callable that returns an appropriate color for a given linkage ID as <code>link_color_func</code> (this function also receives clustering data container which is not required in this example).</p> <p>For example, to give each link/node a different color, one could do this:</p>"},{"location":"guides/custom-colors/#coloring-based-on-cluster-id","title":"Coloring based on cluster ID\u00b6","text":"<p>Often, dendrograms are colored so that all nodes/links that belong to a cluster are painted the same color. This requires knowledge of how to map <code>linkage_id</code> to clustering information. A convenience function <code>idendrogram.callbacks.link_painter</code> is available that does the mapping under the hood - all you need to provide is a list of cluster IDs and corresponding colors, and a color to be used for merged clusters.</p>"},{"location":"guides/custom-colors/#changing-default-text-colors","title":"Changing default text colors\u00b6","text":"<p>Default colors of nodes and links are defined in <code>idendrogram.containers.ClusterNode</code> and  <code>idendrogram.containers.ClusterLink</code>. You can either set different defaults in advance or post-process after the dendrogram is created.</p>"},{"location":"guides/custom-colors/#setting-different-defaults","title":"Setting different defaults\u00b6","text":"<p>The easiest way to change defaults is by defining a new dataclass with appropriate values and passing it to the <code>idendrogram()</code> constructor.</p>"},{"location":"guides/custom-colors/#monochrome-dendrograms","title":"Monochrome dendrograms\u00b6","text":"<p>Note that nodes are still colored using the default <code>link_color_func</code> parameter, so if you want to have a completely single-colored dendrogram version, you need to change that, too.</p>"},{"location":"guides/custom-colors/#coloring-in-post-processing","title":"Coloring in post-processing\u00b6","text":"<p>You can also redefine color values or each node and link separately after the dendrogram has been created.</p>"},{"location":"guides/custom-labels/","title":"Customizing labels","text":"In\u00a0[3]: Copied! <pre>#instantiate idendrogram object and pass clustering data\nidd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\n\n#create a dendrogram object\ndendrogram = idd.create_dendrogram(\n    leaf_label_func = lambda _, linkage_id: str(linkage_id)\n)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> #instantiate idendrogram object and pass clustering data idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data)  #create a dendrogram object dendrogram = idd.create_dendrogram(     leaf_label_func = lambda _, linkage_id: str(linkage_id) ) to_altair(dendrogram=dendrogram, height=200, width=629) Out[3]: In\u00a0[4]: Copied! <pre>dendrogram = idd.create_dendrogram(\n    leaf_label_func = idendrogram.callbacks.counts\n)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> dendrogram = idd.create_dendrogram(     leaf_label_func = idendrogram.callbacks.counts ) to_altair(dendrogram=dendrogram, height=200, width=629) Out[4]: In\u00a0[5]: Copied! <pre>dendrogram = idd.create_dendrogram(\n    leaf_label_func = idendrogram.callbacks.cluster_labeller(\n        fmt_string=\"This is cluster {cluster}\"\n    )\n)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> dendrogram = idd.create_dendrogram(     leaf_label_func = idendrogram.callbacks.cluster_labeller(         fmt_string=\"This is cluster {cluster}\"     ) ) to_altair(dendrogram=dendrogram, height=200, width=629) Out[5]: In\u00a0[6]: Copied! <pre>from idendrogram.containers import AxisLabel\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyAxisLabel(AxisLabel):\n    labelAngle: int = -90\n    \nidd = idendrogram.idendrogram(axis_label_factory=lambda x:  MyAxisLabel(**x))\nidd.set_cluster_info(cl_data)\ndendrogram = idd.create_dendrogram(\n    leaf_label_func = idendrogram.callbacks.cluster_labeller(\n        fmt_string=\"This is cluster {cluster}\"\n    ))\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> from idendrogram.containers import AxisLabel from dataclasses import dataclass  @dataclass class MyAxisLabel(AxisLabel):     labelAngle: int = -90      idd = idendrogram.idendrogram(axis_label_factory=lambda x:  MyAxisLabel(**x)) idd.set_cluster_info(cl_data) dendrogram = idd.create_dendrogram(     leaf_label_func = idendrogram.callbacks.cluster_labeller(         fmt_string=\"This is cluster {cluster}\"     )) to_altair(dendrogram=dendrogram, height=200, width=629) Out[6]: In\u00a0[7]: Copied! <pre>chart = to_altair(dendrogram=dendrogram, height=200, width=629)\nchart.configure_axis(\n    labelFontSize=15,\n    titleFontSize=15\n)\n</pre> chart = to_altair(dendrogram=dendrogram, height=200, width=629) chart.configure_axis(     labelFontSize=15,     titleFontSize=15 ) Out[7]: In\u00a0[8]: Copied! <pre>from idendrogram.containers import ClusterNode\n\n#this is to change default node color/radius for better readability\n@dataclass\nclass MyNode(ClusterNode):\n    fillcolor: str = 'black'\n    _default_leaf_radius: float = 10    \n    radius: float = 20\n    \nidd = idendrogram.idendrogram(node_factory=lambda x: MyNode(**x))\nidd.set_cluster_info(cl_data)\n\n# pass node_label_func a callable that returns linkage_id\ndendrogram = idd.create_dendrogram(\n    node_label_func= lambda _, linkage_id: str(linkage_id),\n)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> from idendrogram.containers import ClusterNode  #this is to change default node color/radius for better readability @dataclass class MyNode(ClusterNode):     fillcolor: str = 'black'     _default_leaf_radius: float = 10         radius: float = 20      idd = idendrogram.idendrogram(node_factory=lambda x: MyNode(**x)) idd.set_cluster_info(cl_data)  # pass node_label_func a callable that returns linkage_id dendrogram = idd.create_dendrogram(     node_label_func= lambda _, linkage_id: str(linkage_id), ) to_altair(dendrogram=dendrogram, height=200, width=629) Out[8]: In\u00a0[9]: Copied! <pre>def custom_label(cl, id):\n    cluster_id = idendrogram.callbacks.cluster_id_if_cluster(cl, id)\n    obs_count = idendrogram.callbacks.counts(cl, id)\n\n    return f\"\"\"C{cluster_id} ({obs_count})\"\"\" if cluster_id != \"\" else \"\"\n\n# pass node_label_func a callable that returns linkage_id\ndendrogram = idd.create_dendrogram(\n    node_label_func= custom_label\n)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> def custom_label(cl, id):     cluster_id = idendrogram.callbacks.cluster_id_if_cluster(cl, id)     obs_count = idendrogram.callbacks.counts(cl, id)      return f\"\"\"C{cluster_id} ({obs_count})\"\"\" if cluster_id != \"\" else \"\"  # pass node_label_func a callable that returns linkage_id dendrogram = idd.create_dendrogram(     node_label_func= custom_label ) to_altair(dendrogram=dendrogram, height=200, width=629) Out[9]: In\u00a0[10]: Copied! <pre>idd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\n\ndendrogram = idd.create_dendrogram(\n    node_hover_func= lambda _, id: {'linkage ID': id}\n)\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data)  dendrogram = idd.create_dendrogram(     node_hover_func= lambda _, id: {'linkage ID': id} ) to_altair(dendrogram=dendrogram, height=200, width=629) Out[10]: <p>idendrogram uses <code>idendrogram.callbacks.default_hover</code> that displays the linkage ID and the # of observations associated with this linkage ID by default.</p> In\u00a0[11]: Copied! <pre>idd = idendrogram.idendrogram()\nidd.set_cluster_info(cl_data)\n\ndendrogram = idd.create_dendrogram(\n    node_hover_func= lambda _, id: {'linkage ID': id}\n)\n\nfor n in dendrogram.nodes:\n    n.hovertext = {\n        'Cluster': idendrogram.callbacks.cluster_assignments(cl_data, n.id),\n        \"Node type\": n.type,\n        \"Node color\": n.fillcolor,\n        \"Original tooltip\": n.hovertext,\n        \"Number of observations\": idendrogram.callbacks.counts(cl_data, n.id)\n    }\n\nto_altair(dendrogram=dendrogram, height=200, width=629)\n</pre> idd = idendrogram.idendrogram() idd.set_cluster_info(cl_data)  dendrogram = idd.create_dendrogram(     node_hover_func= lambda _, id: {'linkage ID': id} )  for n in dendrogram.nodes:     n.hovertext = {         'Cluster': idendrogram.callbacks.cluster_assignments(cl_data, n.id),         \"Node type\": n.type,         \"Node color\": n.fillcolor,         \"Original tooltip\": n.hovertext,         \"Number of observations\": idendrogram.callbacks.counts(cl_data, n.id)     }  to_altair(dendrogram=dendrogram, height=200, width=629) Out[11]:"},{"location":"guides/custom-labels/#customizing-labels","title":"Customizing labels\u00b6","text":""},{"location":"guides/custom-labels/#customizing-leaf-axis-labels","title":"Customizing leaf axis labels\u00b6","text":""},{"location":"guides/custom-labels/#using-leaf_label_func","title":"Using <code>leaf_label_func</code>\u00b6","text":"<p>Leaf axis labels are controlled via <code>leaf_label_func</code> parameter of  <code>idd.create_dendrogram</code> function. To customize labels, pass a callable that returns a desired label for a given linkage ID.</p> <p>For example, to display the linkage ID itself:</p>"},{"location":"guides/custom-labels/#convenience-functions","title":"Convenience functions\u00b6","text":"<p>Two convenience labellers are available:</p> <ul> <li><code>idendrogram.callbacks.counts</code> returns counts of observations represented by the linkage ID. This is the default.</li> <li><code>idendrogram.callbacks.cluster_labeller(fmt_string=[..])</code> returns a callable that returns label only for the first leaf in the cluster, leaving other labels empty.</li> </ul>"},{"location":"guides/custom-labels/#leaf-labels-representing-observation-counts","title":"Leaf labels representing observation counts\u00b6","text":""},{"location":"guides/custom-labels/#leaf-labels-shown-once-per-cluster","title":"Leaf labels shown once per cluster\u00b6","text":""},{"location":"guides/custom-labels/#angles","title":"Angles\u00b6","text":"<p>Angles of leaf labels are defined in <code>idendrogram.containers.ClusterNode</code>. The easiest way to change defaults is by defining a new dataclass with appropriate values and passing it to the <code>idendrogram()</code> constructor.</p>"},{"location":"guides/custom-labels/#text-sizes","title":"Text sizes\u00b6","text":"<p>Text sizes are not natively integrated into idendrogram. You may be able to change them by manipulating the returned objects directly. E.g., in Altair:</p>"},{"location":"guides/custom-labels/#customizing-node-labels","title":"Customizing node labels\u00b6","text":""},{"location":"guides/custom-labels/#using-node_label_func","title":"Using <code>node_label_func</code>\u00b6","text":"<p>Leaf axis labels are controlled via <code>node_label_func</code> parameter of  <code>idd.create_dendrogram</code> function. To customize labels, pass a callable that returns an appropriate label for a given linkage ID.</p> <p>For example, to display the linkage ID itself:</p>"},{"location":"guides/custom-labels/#displaying-cluster-ids","title":"Displaying cluster IDs\u00b6","text":"<p>By default, idendrogram uses <code>idendrogram.callbacks.cluster_id_if_cluster</code> which returns flat cluster ID if the linkage ID corresponds to the flat cluster and empty label otherwise. All callback functions share the same signature, so you can get creative. Here's how you could combine it with <code>idendrogram.callbacks.counts</code> to show cluster ID and the number of observations in the cluster.</p>"},{"location":"guides/custom-labels/#customizing-tooltips","title":"Customizing tooltips\u00b6","text":""},{"location":"guides/custom-labels/#using-node_hover_func","title":"Using <code>node_hover_func</code>\u00b6","text":"<p>Leaf axis labels are controlled via <code>node_hover_func</code> parameter of  <code>idd.create_dendrogram</code> function. To customize labels, pass a callable that returns a dictionary of key:value pairs that will be displayed in a tooltip for a given linkage ID.</p> <p>For example, to display the linkage ID itself:</p>"},{"location":"guides/custom-labels/#customizing-via-postprocessing","title":"Customizing via postprocessing\u00b6","text":"<p>You can also rely on post-processing of dendrograms to customize tooltips. Here's an example using two of available callback functions.</p>"},{"location":"guides/rotating/","title":"Rotating dendrograms","text":"In\u00a0[3]: Copied! <pre>dendrogram = idd.create_dendrogram()\nto_altair(\n    dendrogram=dendrogram, height=200, width=629, \n    orientation=\"top\"\n)\n</pre> dendrogram = idd.create_dendrogram() to_altair(     dendrogram=dendrogram, height=200, width=629,      orientation=\"top\" ) Out[3]: In\u00a0[4]: Copied! <pre>to_altair(\n    dendrogram=dendrogram, height=200, width=629, \n    orientation=\"bottom\"\n)\n</pre> to_altair(     dendrogram=dendrogram, height=200, width=629,      orientation=\"bottom\" ) Out[4]: In\u00a0[5]: Copied! <pre>to_altair(\n    dendrogram=dendrogram, height=200, width=629, \n    orientation=\"left\"\n)\n</pre> to_altair(     dendrogram=dendrogram, height=200, width=629,      orientation=\"left\" ) Out[5]: In\u00a0[6]: Copied! <pre>to_altair(\n    dendrogram=dendrogram, height=200, width=629, \n    orientation=\"right\"\n)\n</pre> to_altair(     dendrogram=dendrogram, height=200, width=629,      orientation=\"right\" ) Out[6]:"},{"location":"guides/rotating/#rotating-dendrograms","title":"Rotating dendrograms\u00b6","text":"<p>idendrogram dendrograms can be rotated by simply passing <code>orientation</code> parameter when visualizing them.</p>"},{"location":"reference/callbacks/","title":"Callback functions for formatting","text":""},{"location":"reference/callbacks/#idendrogram.callbacks.cluster_id_if_cluster","title":"<code>cluster_id_if_cluster(data, linkage_id)</code>","text":"<p>Returns cluster ID if a node belongs to one cluster, otherwise an empty string.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ClusteringData</code> <p>idendrogram.ClusteringData object</p> required <code>linkage_id</code> <code>int</code> <p>linkage ID</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Cluster ID or empty string.</p> Source code in <code>idendrogram/callbacks.py</code> <pre><code>def cluster_id_if_cluster(data: ClusteringData, linkage_id: int) -&gt; str:\n\"\"\"Returns cluster ID if a node belongs to one cluster, otherwise an empty string.\n\n    Args:\n        data (ClusteringData): [idendrogram.ClusteringData][] object\n        linkage_id (int): linkage ID\n\n    Returns:\n        str: Cluster ID or empty string.\n    \"\"\"\n    L, M = data.get_leaders()\n    if linkage_id in L:\n        return str(M[L == linkage_id][0])\n    else:\n        return \"\"\n</code></pre>"},{"location":"reference/callbacks/#idendrogram.callbacks.cluster_labeller","title":"<code>cluster_labeller(fmt_string='Cluster {cluster} ({cluster_size} data points)')</code>","text":"<p>Returns a callable designed to be used as a callback to <code>axis_label_func</code> parameter of idendrogram.idendrogram.create_dendrogram.  Returns a formatted string for the first encountered node in a cluster, otherwise an empty string.</p> <p>Parameters:</p> Name Type Description Default <code>fmt_string</code> <code>str</code> <p>Formatting string. Variables available at the time of evaluation are <code>cluster</code>, <code>cluster_size</code> and <code>linkage_id</code>.</p> <code>'Cluster {cluster} ({cluster_size} data points)'</code> <p>Returns:</p> Type Description <code>Callable[[ClusteringData, int], str]</code> <p>Callable[[ClusteringData, int], str]: Callable designed to be used as a callback to to <code>axis_label_func</code> parameter of idendrogram.idendrogram.create_dendrogram.</p> Source code in <code>idendrogram/callbacks.py</code> <pre><code>def cluster_labeller(\n    fmt_string: str = \"Cluster {cluster} ({cluster_size} data points)\",\n) -&gt; Callable[[ClusteringData, int], str]:\n\"\"\"Returns a callable designed to be used as a callback to `axis_label_func` parameter of [idendrogram.idendrogram.create_dendrogram][]. \n    Returns a formatted string for the first encountered node in a cluster, otherwise an empty string.\n\n    Args:\n        fmt_string (str, optional): Formatting string. Variables available at the time of evaluation are `cluster`, `cluster_size` and `linkage_id`.\n\n    Returns:\n        Callable[[ClusteringData, int], str]: Callable designed to be used as a callback to to `axis_label_func` parameter of [idendrogram.idendrogram.create_dendrogram][].\n    \"\"\"\n\n    seen_clusters = []\n\n    def labeller(data: ClusteringData, linkage_id: int) -&gt; str:\n        _, nodelist = data.get_tree()\n\n        # grab first real leaf node of the passed id\n        leaf_nodes = nodelist[linkage_id].pre_order(\n            lambda x: x.id if x.is_leaf() else None\n        )\n        lf_node = leaf_nodes[0]\n\n        # get its cluster assignment\n        cluster = data.cluster_assignments[lf_node]\n\n        if cluster not in seen_clusters:\n            seen_clusters.append(cluster)\n            # get cluster size\n            cluster_size = nodelist[linkage_id].get_count()\n            return fmt_string.format(\n                cluster=cluster, cluster_size=cluster_size, id=linkage_id\n            )\n        else:\n            return \" \"\n\n    return labeller\n</code></pre>"},{"location":"reference/callbacks/#idendrogram.callbacks.counts","title":"<code>counts(data, linkage_id)</code>","text":"<p>Returns the number of original observations associated with the linkage ID. Used as the default for axis label callback.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ClusteringData</code> <p>idendrogram.ClusteringData object</p> required <code>linkage_id</code> <code>int</code> <p>linkage ID</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>number of original observations (as string)</p> Source code in <code>idendrogram/callbacks.py</code> <pre><code>def counts(data: ClusteringData, linkage_id: int) -&gt; str:\n\"\"\"Returns the number of original observations associated with the linkage ID. Used as the default for axis label callback.\n\n    Args:\n        data (ClusteringData): [idendrogram.ClusteringData][] object\n        linkage_id (int): linkage ID\n\n    Returns:\n        str: number of original observations (as string)\n    \"\"\"\n    _, nodelist = data.get_tree()\n    return str(nodelist[linkage_id].get_count())\n</code></pre>"},{"location":"reference/callbacks/#idendrogram.callbacks.default_hover","title":"<code>default_hover(data, linkage_id)</code>","text":"<p>For a given linkage ID, returns a dictionary with two keys: linkage id and # of items. Used as the default for tooltips.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ClusteringData</code> <p>idendrogram.ClusteringData object</p> required <code>linkage_id</code> <code>int</code> <p>linkage ID</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>Dictionary with attributes</p> Source code in <code>idendrogram/callbacks.py</code> <pre><code>def default_hover(data: ClusteringData, linkage_id: int) -&gt; Dict:\n\"\"\"For a given linkage ID, returns a dictionary with two keys: linkage id and # of items. Used as the default for tooltips.\n\n\n    Args:\n        data (ClusteringData): [idendrogram.ClusteringData][] object\n        linkage_id (int): linkage ID\n\n    Returns:\n        Dict: Dictionary with attributes\n    \"\"\"\n    return {\n        \"# of items\": counts(data=data, linkage_id=linkage_id),\n        \"linkage id\": linkage_id,\n    }\n</code></pre>"},{"location":"reference/callbacks/#idendrogram.callbacks.link_painter","title":"<code>link_painter(colors=dict(), above_threshold='#1f77b4')</code>","text":"<p>Creates a callable compatible with <code>link_color_func</code> argument of idendrogram.idendrogram      that will color nodes based on the cluster they belong to, with a separate color for nodes containing multiple clusters. </p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>Dict</code> <p>Dictionary mapping cluster IDs to colors. Defaults to Matplotlib 10-color scheme.</p> <code>dict()</code> <code>above_threshold</code> <code>str</code> <p>Color to be used for nodes containing multiple clusters.</p> <code>'#1f77b4'</code> <p>Returns:</p> Type Description <code>Callable[[ClusteringData, int], str]</code> <p>Callable[[ClusteringData, int], str]: Callable to be used as <code>link_color_func</code> argument of idendrogram.idendrogram.</p> Example <pre><code>    #your clustering workflow\n    Z = scipy.cluster.hierarchy.linkage(...)\n    cluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, ...) \n\n    # let's assume clustering resulted in 3 clusters and we want to have them as red/blue/green\n    # cluster_assignments.unique == 3\n\n    # define a custom coloring function\n    painter = idendrogram.callbacks.link_painter(\n        colors={\n            1: 'red',\n            2: 'blue',\n            3: 'green',\n        }, \n        above_threshold='black'\n    )\n\n    #create the dendrogram\n    dd = idendrogram.idendrogram()            \n    dd.set_cluster_info(\n        idendrogram.ClusteringData(\n            linkage_matrix=Z, \n            cluster_assignments=cluster_assignments, \n            threshold=threshold \n        )\n    )\n    dd.create_dendrogram(link_color_func = painter).to_plotly()\n</code></pre> Source code in <code>idendrogram/callbacks.py</code> <pre><code>def link_painter(\n    colors: Dict[int, str] = dict(),\n    above_threshold: str = \"#1f77b4\",\n) -&gt; Callable[[ClusteringData, int], str]:\n\"\"\"Creates a callable compatible with `link_color_func` argument of [idendrogram.idendrogram][] \n        that will color nodes based on the cluster they belong to, with a separate color for nodes containing multiple clusters. \n\n    Args:\n        colors (Dict, optional): Dictionary mapping cluster IDs to colors. Defaults to Matplotlib 10-color scheme.\n        above_threshold (str, optional): Color to be used for nodes containing multiple clusters.\n\n    Returns:\n        Callable[[ClusteringData, int], str]: Callable to be used as `link_color_func` argument of [idendrogram.idendrogram][].\n\n    Example:\n        ```\n            #your clustering workflow\n            Z = scipy.cluster.hierarchy.linkage(...)\n            cluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, ...) \n\n            # let's assume clustering resulted in 3 clusters and we want to have them as red/blue/green\n            # cluster_assignments.unique == 3\n\n            # define a custom coloring function\n            painter = idendrogram.callbacks.link_painter(\n                colors={\n                    1: 'red',\n                    2: 'blue',\n                    3: 'green',\n                }, \n                above_threshold='black'\n            )\n\n            #create the dendrogram\n            dd = idendrogram.idendrogram()            \n            dd.set_cluster_info(\n                idendrogram.ClusteringData(\n                    linkage_matrix=Z, \n                    cluster_assignments=cluster_assignments, \n                    threshold=threshold \n                )\n            )\n            dd.create_dendrogram(link_color_func = painter).to_plotly()\n        ```\n    \"\"\"\n    if len(colors) == 0:\n        colors = {\n            1: \"#ff7f0e\",\n            2: \"#2ca02c\",\n            3: \"#d62728\",\n            4: \"#9467bd\",\n            5: \"#8c564b\",\n            6: \"#e377c2\",\n            7: \"#7f7f7f\",\n            8: \"#bcbd22\",\n            9: \"#17becf\",\n        }\n    def _get_color(cluster_assignment: int) -&gt; str:\n        if cluster_assignment in colors.keys():\n            color = colors[cluster_assignment]\n        else:\n            color_index = cluster_assignment % len(colors)\n            color = list(colors.values())[color_index]\n\n        return color\n\n    def link_colors(data: ClusteringData, linkage_id: int) -&gt; str:\n\n        cluster_id = data.get_cluster_id(linkage_id=linkage_id)\n        if cluster_id is None:\n            return above_threshold\n        else:\n            return _get_color(cluster_id)\n\n    return link_colors\n</code></pre>"},{"location":"reference/cluster-info-container/","title":"Clustering Info Container","text":""},{"location":"reference/cluster-info-container/#idendrogram.ClusteringData","title":"<code>idendrogram.ClusteringData</code>","text":"<p>This class is used as a container to store underlying clustering data which may be used by callback functions  in generating the dendrogram. Ensures expensive operations are calculated only once.  </p> Example <pre><code>#your clustering workflow\nZ = scipy.cluster.hierarchy.linkage(...)\nthreshold = 42\ncluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, ...)        \n\n#dendrogram creation\ndd = idendrogram.idendrogram()\ncdata = idendrogram.ClusteringData(\n    linkage_matrix=Z, \n    cluster_assignments=cluster_assignments                \n)\ndd.set_cluster_info(cdata)\n</code></pre> Source code in <code>idendrogram/clustering_data.py</code> <pre><code>class ClusteringData:\n\"\"\"This class is used as a container to store underlying clustering data which may be used by callback functions \n        in generating the dendrogram. Ensures expensive operations are calculated only once.  \n\n        Example:\n\n            ```\n            #your clustering workflow\n            Z = scipy.cluster.hierarchy.linkage(...)\n            threshold = 42\n            cluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, ...)        \n\n            #dendrogram creation\n            dd = idendrogram.idendrogram()\n            cdata = idendrogram.ClusteringData(\n                linkage_matrix=Z, \n                cluster_assignments=cluster_assignments                \n            )\n            dd.set_cluster_info(cdata)\n            ```        \n        \"\"\"\n\n    have_leaders: bool = False\n    leaders: np.ndarray\n    flat_cluster_ids: np.ndarray\n    have_tree: bool = False\n    rootnode: sch.ClusterNode      \n    nodelist: List[sch.ClusterNode]    \n    linkage_matrix: np.ndarray     \n    cluster_assignments: np.ndarray\n\n\n    def __init__(\n        self,\n        linkage_matrix: np.ndarray,\n        cluster_assignments: np.ndarray,        \n        leaders: Tuple[np.ndarray, np.ndarray] = None,\n        rootnode: sch.ClusterNode = None,\n        nodelist: List[sch.ClusterNode] = None,\n    ) -&gt; None:\n\"\"\"Set underlying clustering data that may be used by callback functions in generating the dendrogram. Ensures expensive operations are calculated only once.\n\n        Args:\n            linkage_matrix (np.ndarray): Linkage matrix as produced by \n                `scipy.cluster.hierarchy.linkage` or equivalent\n            cluster_assignments (np.ndarray): A one dimensional array of length N that contains flat cluster assignments for each observation. Produced by `scipy.cluster.hierarchy.fcluster` or equivalent.            \n            leaders (Tuple[np.ndarray, np.ndarray], optional): Root nodes of the clustering produced by `scipy.cluster.hierarchy.leaders()`. \n            rootnode (sch.ClusterNode, optional): rootnode produced by `scipy.cluster.hierarchy.to_tree(..., rd=True)`. \n            nodelist (List[sch.ClusterNode], optional): nodelist produced by `scipy.cluster.hierarchy.to_tree(..., rd=True)`\n\n        Example:\n\n            ```\n            #your clustering workflow\n            Z = scipy.cluster.hierarchy.linkage(...)\n            threshold = 42\n            cluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, ...)        \n\n            #dendrogram creation\n            dd = idendrogram.idendrogram()\n            cdata = idendrogram.ClusteringData(\n                linkage_matrix=Z, \n                cluster_assignments=cluster_assignments,                 \n            )\n            dd.set_cluster_info(cdata)\n            ```            \n        \"\"\"\n        self.linkage_matrix = linkage_matrix\n        self.cluster_assignments = cluster_assignments        \n        if leaders is not None:\n            self.have_leaders = True\n            self.leaders = leaders[0]\n            self.flat_cluster_ids = leaders[1]\n        if rootnode and nodelist:\n            self.have_tree = True\n            self.rootnode = rootnode\n            self.nodelist = nodelist\n\n    def get_leaders(self) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"A wrapper for [scipy.cluster.hierarchy.leaders](https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.leaders.html). Returns the root nodes in a hierarchical clustering.\n\n        Returns:\n            (Tuple[np.ndarray, np.ndarray]):  [L, M] (see SciPy's documentation for details)\n        \"\"\"\n        if not self.have_leaders:\n            L, M = sch.leaders(\n                self.linkage_matrix, self.cluster_assignments\n            )\n            self.leaders = L\n            self.flat_cluster_ids = M\n            self.have_leaders = True\n        return self.leaders, self.flat_cluster_ids\n\n    def get_linkage_matrix(self) -&gt; np.ndarray:\n\"\"\"Returns stored linkage matrix.\n        Returns:\n            linkage_matrix (np.ndarray): Linkage matrix as produced by scipy.cluster.hierarchy.linkage or equivalent.\n        \"\"\"\n        return self.linkage_matrix    \n\n    def get_cluster_assignments(self) -&gt; np.ndarray:\n\"\"\"Returns flat cluster assignment array.\n\n        Returns:\n            cluster_assignments (np.ndarray): A one dimensional array of length N that contains flat cluster assignments for each observation. Produced by `scipy.cluster.hierarchy.fcluster` or equivalent.\n        \"\"\"\n        return self.cluster_assignments\n\n    def get_cluster_id(self, linkage_id: int) -&gt; Optional[int]:\n\"\"\"Returns flat cluster ID for a given linkage ID\n\n        Args:\n            linkage_id (int): Node linkage ID\n\n        Returns:\n            Optional[int]: CLuster ID if a node is within one cluster; None otherwise.\n        \"\"\"\n        L, M = self.get_leaders()\n\n        # check if we are above leaders already\n        if linkage_id &gt; L.max():\n            return None\n\n    # check if this is a leader node\n        if linkage_id in L:\n            return M[L == linkage_id][0]\n\n        _, nodelist = self.get_tree()\n        # Finally, if not grab first real leaf node of the passed id\n        leaf_nodes = nodelist[linkage_id].pre_order(\n            lambda x: x.id if x.is_leaf() else None\n        )\n        lf_node = leaf_nodes[0]\n        # get its cluster assignment\n        cluster = self.cluster_assignments[lf_node]\n        return cluster\n\n    def get_tree(self) -&gt; Tuple[sch.ClusterNode, List[sch.ClusterNode]]:\n\"\"\"A wrapper for [scipy.cluster.hierarchy.to_tree](https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.to_tree.html). Converts a linkage matrix into an easy-to-use tree object.\n\n        Returns:\n            Tuple[scipy.cluster.hierarchy.ClusterNode, List[scipy.cluster.hierarchy.ClusterNode]]: [rootnode, nodelist] (see SciPy's documentation for details)\n        \"\"\"\n        if not self.have_tree:\n            rootnode, nodelist = sch.to_tree(self.linkage_matrix, rd=True)\n            self.rootnode = rootnode\n            self.nodelist = nodelist\n            self.have_tree = True\n        return self.rootnode, self.nodelist\n\n    def get_merge_map(self) -&gt; dict:\n\"\"\"Returns a dictionary that maps pairs of linkage matrix IDs to the linkage matrix ID they get merged into.\n\n        Returns:\n            dict: Dictionary tuple(ID, ID) -&gt; merged_ID\n        \"\"\"\n\n        #create keys that are represented by the pairs of cluster_ids to be merged \n        #e.g. component_ids = [(1,2), (3,4), (5,6)]\n        component_ids = zip(\n            self.linkage_matrix[:, 0].astype(int),\n            self.linkage_matrix[:, 1].astype(int),\n        )\n        #create IDs of the clusters resulting from the merges, i.e. if (1,2) get merged into 5 and (3,4) get merged into 6, \n        # and then (5,6) get merged into 7, this will be [5,6,7]\n        merged_ids = np.arange(\n            self.linkage_matrix.shape[0] + 1,\n            (self.linkage_matrix.shape[0] + 1) * 2 - 1,\n        )\n\n        #create a dictionary that allows to look up a ID resulting from a merge\n        merge_map = dict(zip(component_ids, merged_ids))\n        return merge_map\n</code></pre>"},{"location":"reference/cluster-info-container/#idendrogram.clustering_data.ClusteringData.__init__","title":"<code>__init__(linkage_matrix, cluster_assignments, leaders=None, rootnode=None, nodelist=None)</code>","text":"<p>Set underlying clustering data that may be used by callback functions in generating the dendrogram. Ensures expensive operations are calculated only once.</p> <p>Parameters:</p> Name Type Description Default <code>linkage_matrix</code> <code>np.ndarray</code> <p>Linkage matrix as produced by  <code>scipy.cluster.hierarchy.linkage</code> or equivalent</p> required <code>cluster_assignments</code> <code>np.ndarray</code> <p>A one dimensional array of length N that contains flat cluster assignments for each observation. Produced by <code>scipy.cluster.hierarchy.fcluster</code> or equivalent.            </p> required <code>leaders</code> <code>Tuple[np.ndarray, np.ndarray]</code> <p>Root nodes of the clustering produced by <code>scipy.cluster.hierarchy.leaders()</code>. </p> <code>None</code> <code>rootnode</code> <code>sch.ClusterNode</code> <p>rootnode produced by <code>scipy.cluster.hierarchy.to_tree(..., rd=True)</code>. </p> <code>None</code> <code>nodelist</code> <code>List[sch.ClusterNode]</code> <p>nodelist produced by <code>scipy.cluster.hierarchy.to_tree(..., rd=True)</code></p> <code>None</code> Example <pre><code>#your clustering workflow\nZ = scipy.cluster.hierarchy.linkage(...)\nthreshold = 42\ncluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, ...)        \n\n#dendrogram creation\ndd = idendrogram.idendrogram()\ncdata = idendrogram.ClusteringData(\n    linkage_matrix=Z, \n    cluster_assignments=cluster_assignments,                 \n)\ndd.set_cluster_info(cdata)\n</code></pre> Source code in <code>idendrogram/clustering_data.py</code> <pre><code>def __init__(\n    self,\n    linkage_matrix: np.ndarray,\n    cluster_assignments: np.ndarray,        \n    leaders: Tuple[np.ndarray, np.ndarray] = None,\n    rootnode: sch.ClusterNode = None,\n    nodelist: List[sch.ClusterNode] = None,\n) -&gt; None:\n\"\"\"Set underlying clustering data that may be used by callback functions in generating the dendrogram. Ensures expensive operations are calculated only once.\n\n    Args:\n        linkage_matrix (np.ndarray): Linkage matrix as produced by \n            `scipy.cluster.hierarchy.linkage` or equivalent\n        cluster_assignments (np.ndarray): A one dimensional array of length N that contains flat cluster assignments for each observation. Produced by `scipy.cluster.hierarchy.fcluster` or equivalent.            \n        leaders (Tuple[np.ndarray, np.ndarray], optional): Root nodes of the clustering produced by `scipy.cluster.hierarchy.leaders()`. \n        rootnode (sch.ClusterNode, optional): rootnode produced by `scipy.cluster.hierarchy.to_tree(..., rd=True)`. \n        nodelist (List[sch.ClusterNode], optional): nodelist produced by `scipy.cluster.hierarchy.to_tree(..., rd=True)`\n\n    Example:\n\n        ```\n        #your clustering workflow\n        Z = scipy.cluster.hierarchy.linkage(...)\n        threshold = 42\n        cluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, ...)        \n\n        #dendrogram creation\n        dd = idendrogram.idendrogram()\n        cdata = idendrogram.ClusteringData(\n            linkage_matrix=Z, \n            cluster_assignments=cluster_assignments,                 \n        )\n        dd.set_cluster_info(cdata)\n        ```            \n    \"\"\"\n    self.linkage_matrix = linkage_matrix\n    self.cluster_assignments = cluster_assignments        \n    if leaders is not None:\n        self.have_leaders = True\n        self.leaders = leaders[0]\n        self.flat_cluster_ids = leaders[1]\n    if rootnode and nodelist:\n        self.have_tree = True\n        self.rootnode = rootnode\n        self.nodelist = nodelist\n</code></pre>"},{"location":"reference/cluster-info-container/#idendrogram.clustering_data.ClusteringData.get_cluster_assignments","title":"<code>get_cluster_assignments()</code>","text":"<p>Returns flat cluster assignment array.</p> <p>Returns:</p> Name Type Description <code>cluster_assignments</code> <code>np.ndarray</code> <p>A one dimensional array of length N that contains flat cluster assignments for each observation. Produced by <code>scipy.cluster.hierarchy.fcluster</code> or equivalent.</p> Source code in <code>idendrogram/clustering_data.py</code> <pre><code>def get_cluster_assignments(self) -&gt; np.ndarray:\n\"\"\"Returns flat cluster assignment array.\n\n    Returns:\n        cluster_assignments (np.ndarray): A one dimensional array of length N that contains flat cluster assignments for each observation. Produced by `scipy.cluster.hierarchy.fcluster` or equivalent.\n    \"\"\"\n    return self.cluster_assignments\n</code></pre>"},{"location":"reference/cluster-info-container/#idendrogram.clustering_data.ClusteringData.get_cluster_id","title":"<code>get_cluster_id(linkage_id)</code>","text":"<p>Returns flat cluster ID for a given linkage ID</p> <p>Parameters:</p> Name Type Description Default <code>linkage_id</code> <code>int</code> <p>Node linkage ID</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: CLuster ID if a node is within one cluster; None otherwise.</p> Source code in <code>idendrogram/clustering_data.py</code> <pre><code>def get_cluster_id(self, linkage_id: int) -&gt; Optional[int]:\n\"\"\"Returns flat cluster ID for a given linkage ID\n\n    Args:\n        linkage_id (int): Node linkage ID\n\n    Returns:\n        Optional[int]: CLuster ID if a node is within one cluster; None otherwise.\n    \"\"\"\n    L, M = self.get_leaders()\n\n    # check if we are above leaders already\n    if linkage_id &gt; L.max():\n        return None\n\n# check if this is a leader node\n    if linkage_id in L:\n        return M[L == linkage_id][0]\n\n    _, nodelist = self.get_tree()\n    # Finally, if not grab first real leaf node of the passed id\n    leaf_nodes = nodelist[linkage_id].pre_order(\n        lambda x: x.id if x.is_leaf() else None\n    )\n    lf_node = leaf_nodes[0]\n    # get its cluster assignment\n    cluster = self.cluster_assignments[lf_node]\n    return cluster\n</code></pre>"},{"location":"reference/cluster-info-container/#idendrogram.clustering_data.ClusteringData.get_leaders","title":"<code>get_leaders()</code>","text":"<p>A wrapper for scipy.cluster.hierarchy.leaders. Returns the root nodes in a hierarchical clustering.</p> <p>Returns:</p> Type Description <code>Tuple[np.ndarray, np.ndarray]</code> <p>[L, M] (see SciPy's documentation for details)</p> Source code in <code>idendrogram/clustering_data.py</code> <pre><code>def get_leaders(self) -&gt; Tuple[np.ndarray, np.ndarray]:\n\"\"\"A wrapper for [scipy.cluster.hierarchy.leaders](https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.leaders.html). Returns the root nodes in a hierarchical clustering.\n\n    Returns:\n        (Tuple[np.ndarray, np.ndarray]):  [L, M] (see SciPy's documentation for details)\n    \"\"\"\n    if not self.have_leaders:\n        L, M = sch.leaders(\n            self.linkage_matrix, self.cluster_assignments\n        )\n        self.leaders = L\n        self.flat_cluster_ids = M\n        self.have_leaders = True\n    return self.leaders, self.flat_cluster_ids\n</code></pre>"},{"location":"reference/cluster-info-container/#idendrogram.clustering_data.ClusteringData.get_linkage_matrix","title":"<code>get_linkage_matrix()</code>","text":"<p>Returns stored linkage matrix.</p> <p>Returns:</p> Name Type Description <code>linkage_matrix</code> <code>np.ndarray</code> <p>Linkage matrix as produced by scipy.cluster.hierarchy.linkage or equivalent.</p> Source code in <code>idendrogram/clustering_data.py</code> <pre><code>def get_linkage_matrix(self) -&gt; np.ndarray:\n\"\"\"Returns stored linkage matrix.\n    Returns:\n        linkage_matrix (np.ndarray): Linkage matrix as produced by scipy.cluster.hierarchy.linkage or equivalent.\n    \"\"\"\n    return self.linkage_matrix    \n</code></pre>"},{"location":"reference/cluster-info-container/#idendrogram.clustering_data.ClusteringData.get_merge_map","title":"<code>get_merge_map()</code>","text":"<p>Returns a dictionary that maps pairs of linkage matrix IDs to the linkage matrix ID they get merged into.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary tuple(ID, ID) -&gt; merged_ID</p> Source code in <code>idendrogram/clustering_data.py</code> <pre><code>def get_merge_map(self) -&gt; dict:\n\"\"\"Returns a dictionary that maps pairs of linkage matrix IDs to the linkage matrix ID they get merged into.\n\n    Returns:\n        dict: Dictionary tuple(ID, ID) -&gt; merged_ID\n    \"\"\"\n\n    #create keys that are represented by the pairs of cluster_ids to be merged \n    #e.g. component_ids = [(1,2), (3,4), (5,6)]\n    component_ids = zip(\n        self.linkage_matrix[:, 0].astype(int),\n        self.linkage_matrix[:, 1].astype(int),\n    )\n    #create IDs of the clusters resulting from the merges, i.e. if (1,2) get merged into 5 and (3,4) get merged into 6, \n    # and then (5,6) get merged into 7, this will be [5,6,7]\n    merged_ids = np.arange(\n        self.linkage_matrix.shape[0] + 1,\n        (self.linkage_matrix.shape[0] + 1) * 2 - 1,\n    )\n\n    #create a dictionary that allows to look up a ID resulting from a merge\n    merge_map = dict(zip(component_ids, merged_ids))\n    return merge_map\n</code></pre>"},{"location":"reference/cluster-info-container/#idendrogram.clustering_data.ClusteringData.get_tree","title":"<code>get_tree()</code>","text":"<p>A wrapper for scipy.cluster.hierarchy.to_tree. Converts a linkage matrix into an easy-to-use tree object.</p> <p>Returns:</p> Type Description <code>Tuple[sch.ClusterNode, List[sch.ClusterNode]]</code> <p>Tuple[scipy.cluster.hierarchy.ClusterNode, List[scipy.cluster.hierarchy.ClusterNode]]: [rootnode, nodelist] (see SciPy's documentation for details)</p> Source code in <code>idendrogram/clustering_data.py</code> <pre><code>def get_tree(self) -&gt; Tuple[sch.ClusterNode, List[sch.ClusterNode]]:\n\"\"\"A wrapper for [scipy.cluster.hierarchy.to_tree](https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.to_tree.html). Converts a linkage matrix into an easy-to-use tree object.\n\n    Returns:\n        Tuple[scipy.cluster.hierarchy.ClusterNode, List[scipy.cluster.hierarchy.ClusterNode]]: [rootnode, nodelist] (see SciPy's documentation for details)\n    \"\"\"\n    if not self.have_tree:\n        rootnode, nodelist = sch.to_tree(self.linkage_matrix, rd=True)\n        self.rootnode = rootnode\n        self.nodelist = nodelist\n        self.have_tree = True\n    return self.rootnode, self.nodelist\n</code></pre>"},{"location":"reference/data_containers/","title":"Data Containers","text":""},{"location":"reference/data_containers/#idendrogram.Dendrogram","title":"<code>idendrogram.Dendrogram</code>  <code>dataclass</code>","text":"<p>Dataclass representing the idendrogram dendrogram object.</p> Source code in <code>idendrogram/containers.py</code> <pre><code>@dataclass\nclass Dendrogram:\n\"\"\"Dataclass representing the idendrogram dendrogram object.\n    \"\"\"\n\n    axis_labels: List[AxisLabel]\n\"\"\"axis_labels: list of AxisLabel objects\"\"\"\n    links: List[ClusterLink]\n\"\"\"links: list of ClusterLink objects\"\"\"\n    nodes: List[ClusterNode]\n\"\"\"nodes: list of ClusterNode objects\"\"\"\n    computed_nodes: bool = True\n\"\"\"computed_nodes: boolean indicating if Cluster Nodes were computed at creation time\"\"\"\n    x_domain: Tuple[float, float] = (0, 0)\n\"\"\"x_domain: the value domain of the label axis\"\"\"\n    y_domain: Tuple[float, float] = (0, 0)\n\"\"\"y_domain: the value domain of the value axis\"\"\"\n\n    def plot(\n        self,\n        backend: str = \"altair\",\n        orientation: str = \"top\",\n        show_nodes: bool = True,\n        height: float = 400,\n        width: float = 400,\n        scale: str = \"linear\",\n    ) -&gt; Any:\n\"\"\"\n        Plot the dendrogram using one of the supported backends. This is a convenience function,\n            you can also use `to_*()` functions from appropriate target backends at `idendrogram.targets.[backend].to_[backend]()`.\n\n        Args:\n            backend (str, optional): Backend to use, one of 'altair', 'streamlit', 'plotly', 'matplotlib'. \n            orientation (str, optional): Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". \n            show_nodes (bool, optional): Whether to draw nodes. \n            height (float, optional): Height of the dendrogram. \n            width (float, optional): Width of the dendrogram. \n            scale (str, optional): Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". \n\n        Raises:\n            ValueError: Parameters supplied did not comform to allowed values.  \n\n        Returns:\n            Any: \n\n                Varies by backend: \n\n                - Altair: `altair.Layered` chart object\n                - Plotly: `plotly.graph_objs.Figure` figure object\n                - Matplotlib: `matplotlib.pyplot.ax` axes object\n                - Streamlit: [idendrogram.ClusterNode][] object that was clicked on (None if no clicks took place)\n        \"\"\"\n        if backend == 'altair':\n            from .targets.altair import to_altair\n            return to_altair(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n        elif backend == 'matplotlib':\n            from .targets.matplotlib import to_matplotlib\n            return to_matplotlib(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n        elif backend == 'plotly':\n            from .targets.plotly import to_plotly\n            return to_plotly(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n        elif backend == 'streamlit':\n            from .targets.streamlit import to_streamlit\n            return to_streamlit(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n        else:\n            raise ValueError(f\"Unsupported backend '{backend}', should be one of 'plotly', 'matplotlib', 'altair', 'streamlit'\")\n\n    def to_json(self) -&gt; str:\n\"\"\"Converts dendrogram to JSON representation.\n\n        Returns:\n            str: JSON-formatted dendrogram\n        \"\"\"\n        from .targets.json import to_json\n        return to_json(self)\n</code></pre>"},{"location":"reference/data_containers/#idendrogram.containers.Dendrogram.axis_labels","title":"<code>axis_labels: List[AxisLabel]</code>  <code>instance-attribute</code>","text":"<p>axis_labels: list of AxisLabel objects</p>"},{"location":"reference/data_containers/#idendrogram.containers.Dendrogram.computed_nodes","title":"<code>computed_nodes: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>computed_nodes: boolean indicating if Cluster Nodes were computed at creation time</p>"},{"location":"reference/data_containers/#idendrogram.containers.Dendrogram.links","title":"<code>links: List[ClusterLink]</code>  <code>instance-attribute</code>","text":"<p>links: list of ClusterLink objects</p>"},{"location":"reference/data_containers/#idendrogram.containers.Dendrogram.nodes","title":"<code>nodes: List[ClusterNode]</code>  <code>instance-attribute</code>","text":"<p>nodes: list of ClusterNode objects</p>"},{"location":"reference/data_containers/#idendrogram.containers.Dendrogram.x_domain","title":"<code>x_domain: Tuple[float, float] = (0, 0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>x_domain: the value domain of the label axis</p>"},{"location":"reference/data_containers/#idendrogram.containers.Dendrogram.y_domain","title":"<code>y_domain: Tuple[float, float] = (0, 0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>y_domain: the value domain of the value axis</p>"},{"location":"reference/data_containers/#idendrogram.containers.Dendrogram.plot","title":"<code>plot(backend='altair', orientation='top', show_nodes=True, height=400, width=400, scale='linear')</code>","text":"<p>Plot the dendrogram using one of the supported backends. This is a convenience function,     you can also use <code>to_*()</code> functions from appropriate target backends at <code>idendrogram.targets.[backend].to_[backend]()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Backend to use, one of 'altair', 'streamlit', 'plotly', 'matplotlib'. </p> <code>'altair'</code> <code>orientation</code> <code>str</code> <p>Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". </p> <code>'top'</code> <code>show_nodes</code> <code>bool</code> <p>Whether to draw nodes. </p> <code>True</code> <code>height</code> <code>float</code> <p>Height of the dendrogram. </p> <code>400</code> <code>width</code> <code>float</code> <p>Width of the dendrogram. </p> <code>400</code> <code>scale</code> <code>str</code> <p>Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". </p> <code>'linear'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Parameters supplied did not comform to allowed values.  </p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Varies by backend: </p> <ul> <li>Altair: <code>altair.Layered</code> chart object</li> <li>Plotly: <code>plotly.graph_objs.Figure</code> figure object</li> <li>Matplotlib: <code>matplotlib.pyplot.ax</code> axes object</li> <li>Streamlit: idendrogram.ClusterNode object that was clicked on (None if no clicks took place)</li> </ul> Source code in <code>idendrogram/containers.py</code> <pre><code>def plot(\n    self,\n    backend: str = \"altair\",\n    orientation: str = \"top\",\n    show_nodes: bool = True,\n    height: float = 400,\n    width: float = 400,\n    scale: str = \"linear\",\n) -&gt; Any:\n\"\"\"\n    Plot the dendrogram using one of the supported backends. This is a convenience function,\n        you can also use `to_*()` functions from appropriate target backends at `idendrogram.targets.[backend].to_[backend]()`.\n\n    Args:\n        backend (str, optional): Backend to use, one of 'altair', 'streamlit', 'plotly', 'matplotlib'. \n        orientation (str, optional): Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". \n        show_nodes (bool, optional): Whether to draw nodes. \n        height (float, optional): Height of the dendrogram. \n        width (float, optional): Width of the dendrogram. \n        scale (str, optional): Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". \n\n    Raises:\n        ValueError: Parameters supplied did not comform to allowed values.  \n\n    Returns:\n        Any: \n\n            Varies by backend: \n\n            - Altair: `altair.Layered` chart object\n            - Plotly: `plotly.graph_objs.Figure` figure object\n            - Matplotlib: `matplotlib.pyplot.ax` axes object\n            - Streamlit: [idendrogram.ClusterNode][] object that was clicked on (None if no clicks took place)\n    \"\"\"\n    if backend == 'altair':\n        from .targets.altair import to_altair\n        return to_altair(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n    elif backend == 'matplotlib':\n        from .targets.matplotlib import to_matplotlib\n        return to_matplotlib(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n    elif backend == 'plotly':\n        from .targets.plotly import to_plotly\n        return to_plotly(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n    elif backend == 'streamlit':\n        from .targets.streamlit import to_streamlit\n        return to_streamlit(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n    else:\n        raise ValueError(f\"Unsupported backend '{backend}', should be one of 'plotly', 'matplotlib', 'altair', 'streamlit'\")\n</code></pre>"},{"location":"reference/data_containers/#idendrogram.containers.Dendrogram.to_json","title":"<code>to_json()</code>","text":"<p>Converts dendrogram to JSON representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON-formatted dendrogram</p> Source code in <code>idendrogram/containers.py</code> <pre><code>def to_json(self) -&gt; str:\n\"\"\"Converts dendrogram to JSON representation.\n\n    Returns:\n        str: JSON-formatted dendrogram\n    \"\"\"\n    from .targets.json import to_json\n    return to_json(self)\n</code></pre>"},{"location":"reference/data_containers/#idendrogram.AxisLabel","title":"<code>idendrogram.AxisLabel</code>  <code>dataclass</code>","text":"<p>Dataclass storing information on axis labels.</p> Source code in <code>idendrogram/containers.py</code> <pre><code>@dataclass\nclass AxisLabel:\n\"\"\"Dataclass storing information on axis labels.\"\"\"\n\n    x: float\n\"\"\"x-coordinate of the label\"\"\"\n    label: str\n\"\"\"label text\"\"\"\n    labelAngle: float = 0\n\"\"\"rotation of the text label (in degrees)\"\"\"\n</code></pre>"},{"location":"reference/data_containers/#idendrogram.containers.AxisLabel.label","title":"<code>label: str</code>  <code>instance-attribute</code>","text":"<p>label text</p>"},{"location":"reference/data_containers/#idendrogram.containers.AxisLabel.labelAngle","title":"<code>labelAngle: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>rotation of the text label (in degrees)</p>"},{"location":"reference/data_containers/#idendrogram.containers.AxisLabel.x","title":"<code>x: float</code>  <code>instance-attribute</code>","text":"<p>x-coordinate of the label</p>"},{"location":"reference/data_containers/#idendrogram.ClusterLink","title":"<code>idendrogram.ClusterLink</code>  <code>dataclass</code>","text":"<p>Dataclass storing information about links.</p> Source code in <code>idendrogram/containers.py</code> <pre><code>@dataclass\nclass ClusterLink:\n\"\"\"Dataclass storing information about links.\"\"\"\n\n    x: List[float]\n\"\"\"x: 4 coordinates of the link on the x-axis\"\"\"\n    y: List[float]\n\"\"\"y: 4 coordinates of the link on the y-axis\"\"\"\n    fillcolor: str\n\"\"\"fillcolor: line color used for the link\"\"\"\n    id: Union[int, None] = None\n\"\"\"id: the linkage ID represented by the link\"\"\"\n    children_id: Union[Tuple[int, int], None] = None\n\"\"\"children_id: a tuple of 2 linkage IDs representing the 2 immediate clusters that got merged into this cluster\"\"\"\n    cluster_id: Union[int, None] = None\n\"\"\"cluster_id: flat cluster assignment ID if this link represents a flat cluster; otherwise empty\"\"\"\n    strokewidth: float = 1.0\n\"\"\"strokewidth: the line width of the link\"\"\"\n    strokedash: List = field(default_factory=lambda: [1, 0])\n\"\"\"strokedash: the dash pattern used for the link\"\"\"\n    strokeopacity: float = 1.0\n\"\"\"strokeopacity: the opacity level used for the link\"\"\"\n    _order_helper: List = field(default_factory=lambda: [0, 1, 2, 3])\n</code></pre>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.children_id","title":"<code>children_id: Union[Tuple[int, int], None] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>children_id: a tuple of 2 linkage IDs representing the 2 immediate clusters that got merged into this cluster</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.cluster_id","title":"<code>cluster_id: Union[int, None] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>cluster_id: flat cluster assignment ID if this link represents a flat cluster; otherwise empty</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.fillcolor","title":"<code>fillcolor: str</code>  <code>instance-attribute</code>","text":"<p>fillcolor: line color used for the link</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.id","title":"<code>id: Union[int, None] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>id: the linkage ID represented by the link</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.strokedash","title":"<code>strokedash: List = field(default_factory=lambda : [1, 0])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>strokedash: the dash pattern used for the link</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.strokeopacity","title":"<code>strokeopacity: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>strokeopacity: the opacity level used for the link</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.strokewidth","title":"<code>strokewidth: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>strokewidth: the line width of the link</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.x","title":"<code>x: List[float]</code>  <code>instance-attribute</code>","text":"<p>x: 4 coordinates of the link on the x-axis</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterLink.y","title":"<code>y: List[float]</code>  <code>instance-attribute</code>","text":"<p>y: 4 coordinates of the link on the y-axis</p>"},{"location":"reference/data_containers/#idendrogram.ClusterNode","title":"<code>idendrogram.ClusterNode</code>  <code>dataclass</code>","text":"<p>Data class storing node-level information.</p> Source code in <code>idendrogram/containers.py</code> <pre><code>@dataclass\nclass ClusterNode:\n\"\"\"Data class storing node-level information.\"\"\"\n\n    x: float\n\"\"\"X-coordinate of the node\"\"\"\n    y: float\n\"\"\"Y-coordinate of the node\"\"\"\n    type: str\n\"\"\"Type of the node. One of `leaf`, `subcluster`, `cluster`, `supercluster` \"\"\"\n    id: int\n\"\"\"Linkage ID the node represents\"\"\"\n    cluster_id: Union[int, None]\n\"\"\"flat cluster assignment ID if this link represents a flat cluster; otherwise empty\"\"\"\n    edgecolor: str\n\"\"\"color used for the edge of the node\"\"\"\n    label: str = \"\"\n\"\"\"text label displayed on the node\"\"\"\n    hovertext: Dict[str, str] = field(default_factory=dict)\n\"\"\"Information displayed on a tooltip, in dictionary form (key: values)\"\"\"\n    fillcolor: str = \"#fff\"\n\"\"\"colors used to fill the node\"\"\"\n    radius: float = 7.0\n\"\"\"radius of the node\"\"\"\n    opacity: float = 1.0\n\"\"\"opacity level of the node\"\"\"\n    labelsize: float = 10.0\n\"\"\"size of the text label displayed\"\"\"\n    labelcolor: str = \"#fff\"\n\"\"\"color of the text label displayed\"\"\"\n    _default_leaf_radius: float = 4.0\n\"\"\"size of the radius of the leaf nodes\"\"\"\n    _default_leaf_radius_if_cluster: float = 7.0\n\"\"\"size of the radius of the leaf nodes\"\"\"\n</code></pre>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.cluster_id","title":"<code>cluster_id: Union[int, None]</code>  <code>instance-attribute</code>","text":"<p>flat cluster assignment ID if this link represents a flat cluster; otherwise empty</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.edgecolor","title":"<code>edgecolor: str</code>  <code>instance-attribute</code>","text":"<p>color used for the edge of the node</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.fillcolor","title":"<code>fillcolor: str = '#fff'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>colors used to fill the node</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.hovertext","title":"<code>hovertext: Dict[str, str] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Information displayed on a tooltip, in dictionary form (key: values)</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":"<p>Linkage ID the node represents</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.label","title":"<code>label: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>text label displayed on the node</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.labelcolor","title":"<code>labelcolor: str = '#fff'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>color of the text label displayed</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.labelsize","title":"<code>labelsize: float = 10.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>size of the text label displayed</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.opacity","title":"<code>opacity: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>opacity level of the node</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.radius","title":"<code>radius: float = 7.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>radius of the node</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.type","title":"<code>type: str</code>  <code>instance-attribute</code>","text":"<p>Type of the node. One of <code>leaf</code>, <code>subcluster</code>, <code>cluster</code>, <code>supercluster</code></p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.x","title":"<code>x: float</code>  <code>instance-attribute</code>","text":"<p>X-coordinate of the node</p>"},{"location":"reference/data_containers/#idendrogram.containers.ClusterNode.y","title":"<code>y: float</code>  <code>instance-attribute</code>","text":"<p>Y-coordinate of the node</p>"},{"location":"reference/dendrogram/","title":"Plotting dendrograms","text":""},{"location":"reference/dendrogram/#convenience-wrapper","title":"Convenience wrapper","text":""},{"location":"reference/dendrogram/#idendrogramdendrogramplot","title":"<code>idendrogram.Dendrogram.plot(...)</code>","text":"<p>Plot the dendrogram using one of the supported backends. This is a convenience function,     you can also use <code>to_*()</code> functions from appropriate target backends at <code>idendrogram.targets.[backend].to_[backend]()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Backend to use, one of 'altair', 'streamlit', 'plotly', 'matplotlib'. </p> <code>'altair'</code> <code>orientation</code> <code>str</code> <p>Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". </p> <code>'top'</code> <code>show_nodes</code> <code>bool</code> <p>Whether to draw nodes. </p> <code>True</code> <code>height</code> <code>float</code> <p>Height of the dendrogram. </p> <code>400</code> <code>width</code> <code>float</code> <p>Width of the dendrogram. </p> <code>400</code> <code>scale</code> <code>str</code> <p>Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". </p> <code>'linear'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Parameters supplied did not comform to allowed values.  </p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Varies by backend: </p> <ul> <li>Altair: <code>altair.Layered</code> chart object</li> <li>Plotly: <code>plotly.graph_objs.Figure</code> figure object</li> <li>Matplotlib: <code>matplotlib.pyplot.ax</code> axes object</li> <li>Streamlit: idendrogram.ClusterNode object that was clicked on (None if no clicks took place)</li> </ul> Source code in <code>idendrogram/containers.py</code> <pre><code>def plot(\n    self,\n    backend: str = \"altair\",\n    orientation: str = \"top\",\n    show_nodes: bool = True,\n    height: float = 400,\n    width: float = 400,\n    scale: str = \"linear\",\n) -&gt; Any:\n\"\"\"\n    Plot the dendrogram using one of the supported backends. This is a convenience function,\n        you can also use `to_*()` functions from appropriate target backends at `idendrogram.targets.[backend].to_[backend]()`.\n\n    Args:\n        backend (str, optional): Backend to use, one of 'altair', 'streamlit', 'plotly', 'matplotlib'. \n        orientation (str, optional): Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". \n        show_nodes (bool, optional): Whether to draw nodes. \n        height (float, optional): Height of the dendrogram. \n        width (float, optional): Width of the dendrogram. \n        scale (str, optional): Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". \n\n    Raises:\n        ValueError: Parameters supplied did not comform to allowed values.  \n\n    Returns:\n        Any: \n\n            Varies by backend: \n\n            - Altair: `altair.Layered` chart object\n            - Plotly: `plotly.graph_objs.Figure` figure object\n            - Matplotlib: `matplotlib.pyplot.ax` axes object\n            - Streamlit: [idendrogram.ClusterNode][] object that was clicked on (None if no clicks took place)\n    \"\"\"\n    if backend == 'altair':\n        from .targets.altair import to_altair\n        return to_altair(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n    elif backend == 'matplotlib':\n        from .targets.matplotlib import to_matplotlib\n        return to_matplotlib(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n    elif backend == 'plotly':\n        from .targets.plotly import to_plotly\n        return to_plotly(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n    elif backend == 'streamlit':\n        from .targets.streamlit import to_streamlit\n        return to_streamlit(self, orientation=orientation, show_nodes=show_nodes, height=height, width=width, scale=scale)\n    else:\n        raise ValueError(f\"Unsupported backend '{backend}', should be one of 'plotly', 'matplotlib', 'altair', 'streamlit'\")\n</code></pre>"},{"location":"reference/dendrogram/#backend-specific-functions","title":"Backend-specific functions","text":""},{"location":"reference/dendrogram/#idendrogramtargetsaltairto_altair","title":"<code>idendrogram.targets.altair.to_altair(...)</code>","text":"<p>Converts a dendrogram object into Altair chart.</p> <p>Parameters:</p> Name Type Description Default <code>dendrogram</code> <code>Dendrogram</code> <p>idendrogram dendrogram object</p> required <code>orientation</code> <code>str</code> <p>Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". Defaults to \"top\".</p> <code>'top'</code> <code>show_nodes</code> <code>bool</code> <p>Whether to draw nodes. Defaults to True.</p> <code>True</code> <code>height</code> <code>float</code> <p>Height of the dendrogram. Defaults to 400.</p> <code>400</code> <code>width</code> <code>float</code> <p>Width of the dendrogram. Defaults to 400.</p> <code>400</code> <code>scale</code> <code>str</code> <p>Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". Defaults to 'linear'.</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>alt.LayerChart</code> <p>Altair chart object</p> Source code in <code>idendrogram/targets/altair.py</code> <pre><code>def to_altair(\n    dendrogram: Dendrogram,\n    orientation: str = \"top\",\n    show_nodes: bool = True,\n    height: float = 400,\n    width: float = 400,\n    scale: str = \"linear\",\n) -&gt; alt.LayerChart:\n\"\"\"Converts a dendrogram object into Altair chart.\n\n    Args:\n        dendrogram (Dendrogram): idendrogram dendrogram object\n        orientation (str, optional): Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". Defaults to \"top\".\n        show_nodes (bool, optional): Whether to draw nodes. Defaults to True.\n        height (float, optional): Height of the dendrogram. Defaults to 400.\n        width (float, optional): Width of the dendrogram. Defaults to 400.\n        scale (str, optional): Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". Defaults to 'linear'.\n\n    Returns:\n        Altair chart object\n    \"\"\"\n    _check_orientation(dendrogram, orientation)\n    _check_scale(dendrogram, scale)\n    _check_nodes(dendrogram, show_nodes)\n\n    return AltairConverter().convert(\n        dendrogram=dendrogram,\n        orientation=orientation,\n        show_nodes=show_nodes,\n        height=height,\n        width=width,\n        scale=scale,\n    )\n</code></pre>"},{"location":"reference/dendrogram/#idendrogramtargetsaltairto_plotly","title":"<code>idendrogram.targets.altair.to_plotly(...)</code>","text":"<p>Converts a dendrogram object into Plotly chart</p> <p>Parameters:</p> Name Type Description Default <code>dendrogram</code> <code>Dendrogram</code> <p>idendrogram dendrogram object</p> required <code>orientation</code> <code>str</code> <p>Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". Defaults to \"top\".</p> <code>'top'</code> <code>show_nodes</code> <code>bool</code> <p>Whether to draw nodes. Defaults to True.</p> <code>True</code> <code>height</code> <code>float</code> <p>Height of the dendrogram. Defaults to 400.</p> <code>400</code> <code>width</code> <code>float</code> <p>Width of the dendrogram. Defaults to 400.</p> <code>400</code> <code>scale</code> <code>str</code> <p>Scale used for the value axis. One of \"linear\", \"log\". \"symlog\" is not supported by Plotly. Defaults to 'linear'.</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>Any</code> <p>plotly.graph_objs.Figure: Plotly figure object</p> Source code in <code>idendrogram/targets/plotly.py</code> <pre><code>def to_plotly(\n        dendrogram: Dendrogram,\n        orientation: str = \"top\",\n        show_nodes: bool = True,\n        height: float = 400,\n        width: float = 400,\n        scale: str = \"linear\",\n    ) -&gt; Any:\n\"\"\"Converts a dendrogram object into Plotly chart\n\n        Args:\n            dendrogram (Dendrogram): idendrogram dendrogram object\n            orientation (str, optional): Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". Defaults to \"top\".\n            show_nodes (bool, optional): Whether to draw nodes. Defaults to True.\n            height (float, optional): Height of the dendrogram. Defaults to 400.\n            width (float, optional): Width of the dendrogram. Defaults to 400.\n            scale (str, optional): Scale used for the value axis. One of \"linear\", \"log\". \"symlog\" is not supported by Plotly. Defaults to 'linear'.\n\n        Returns:\n            plotly.graph_objs.Figure: Plotly figure object\n        \"\"\"\n        _check_orientation(dendrogram, orientation)\n        _check_scale(dendrogram, scale, supported=[\"linear\", \"log\"])\n        _check_nodes(dendrogram, show_nodes)\n\n        return PlotlyConverter().convert(\n            dendrogram=dendrogram,\n            orientation=orientation,\n            show_nodes=show_nodes,\n            height=height,\n            width=width,\n            scale=scale,\n        )\n</code></pre>"},{"location":"reference/dendrogram/#idendrogramtargetsaltairto_matplotlib","title":"<code>idendrogram.targets.altair.to_matplotlib(...)</code>","text":"<p>Converts a dendrogram object into matplotlib chart</p> <p>Parameters:</p> Name Type Description Default <code>dendrogram</code> <code>Dendrogram</code> <p>idendrogram dendrogram object</p> required <code>orientation</code> <code>str</code> <p>Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". Defaults to \"top\".</p> <code>'top'</code> <code>show_nodes</code> <code>bool</code> <p>Whether to draw nodes. Defaults to True.</p> <code>True</code> <code>height</code> <code>float</code> <p>Height of the dendrogram. Defaults to 400.</p> <code>400</code> <code>width</code> <code>float</code> <p>Width of the dendrogram. Defaults to 400.</p> <code>400</code> <code>scale</code> <code>str</code> <p>Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". Defaults to 'linear'.</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>Axes</code> <p>matplotlib.pyplot.ax: matplotlib axes object</p> Source code in <code>idendrogram/targets/matplotlib.py</code> <pre><code>def to_matplotlib(\n        dendrogram: Dendrogram,\n        orientation: str = \"top\",\n        show_nodes: bool = True,\n        height: float = 400,\n        width: float = 400,\n        scale: str = \"linear\",\n    ) -&gt; Axes:\n\"\"\"Converts a dendrogram object into matplotlib chart\n\n        Args:\n            dendrogram (Dendrogram): idendrogram dendrogram object\n            orientation (str, optional): Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". Defaults to \"top\".\n            show_nodes (bool, optional): Whether to draw nodes. Defaults to True.\n            height (float, optional): Height of the dendrogram. Defaults to 400.\n            width (float, optional): Width of the dendrogram. Defaults to 400.\n            scale (str, optional): Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". Defaults to 'linear'.\n\n        Returns:\n            matplotlib.pyplot.ax: matplotlib axes object\n        \"\"\"\n        _check_orientation(dendrogram, orientation)\n        _check_scale(dendrogram, scale)\n        _check_nodes(dendrogram, show_nodes)\n\n        return matplotlibConverter().convert(\n            dendrogram=dendrogram,\n            orientation=orientation,\n            show_nodes=show_nodes,\n            height=height,\n            width=width,\n            scale=scale,\n        )\n</code></pre>"},{"location":"reference/dendrogram/#idendrogramtargetsaltairto_streamlit","title":"<code>idendrogram.targets.altair.to_streamlit(...)</code>","text":"<p>Renders dendrogram object as a custom bi-directional Streamlit component</p> <p>Parameters:</p> Name Type Description Default <code>dendrogram</code> <code>Dendrogram</code> <p>idendrogram dendrogram object</p> required <code>orientation</code> <code>str</code> <p>Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". Defaults to \"top\".</p> <code>'top'</code> <code>show_nodes</code> <code>bool</code> <p>Whether to draw nodes. Defaults to True.</p> <code>True</code> <code>height</code> <code>float</code> <p>Height of the dendrogram. Defaults to 400.</p> <code>400</code> <code>width</code> <code>float</code> <p>Width of the dendrogram. Defaults to 400.</p> <code>400</code> <code>scale</code> <code>str</code> <p>Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". Defaults to 'linear'.</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>Optional[ClusterNode]</code> <p>Optional[ClusterNode]: A ClusterNode object that was clicked on (None if no clicks took place)</p> Source code in <code>idendrogram/targets/streamlit.py</code> <pre><code>def to_streamlit(\n    dendrogram: Dendrogram,\n    orientation: str = \"top\",\n    show_nodes: bool = True,\n    height: float = 400,\n    width: float = 400,\n    scale: str = \"linear\",\n) -&gt; Optional[ClusterNode]:\n\"\"\"Renders dendrogram object as a custom bi-directional Streamlit component\n\n    Args:\n        dendrogram (Dendrogram): idendrogram dendrogram object\n        orientation (str, optional): Position of dendrogram's root node. One of \"top\", \"bottom\", \"left\", \"right\". Defaults to \"top\".\n        show_nodes (bool, optional): Whether to draw nodes. Defaults to True.\n        height (float, optional): Height of the dendrogram. Defaults to 400.\n        width (float, optional): Width of the dendrogram. Defaults to 400.\n        scale (str, optional): Scale used for the value axis. One of \"linear\", \"symlog\", \"log\". Defaults to 'linear'.\n\n    Returns:\n        Optional[ClusterNode]: A ClusterNode object that was clicked on (None if no clicks took place)\n    \"\"\"\n\n    _check_orientation(dendrogram, orientation)\n    _check_scale(dendrogram, scale)\n    _check_nodes(dendrogram, show_nodes)\n\n    return idendrogram_streamlit.StreamlitConverter(release=True).convert(\n        dendrogram=dendrogram,\n        orientation=orientation,\n        show_nodes=show_nodes,\n        height=height,\n        width=width,\n        key=\"idendrogram\",\n        scale=scale,\n    )\n</code></pre>"},{"location":"reference/reference/","title":"Creating dendrogram objects","text":""},{"location":"reference/reference/#idendrogram.idendrogram","title":"<code>idendrogram.idendrogram</code>","text":""},{"location":"reference/reference/#idendrogram.base.idendrogram.__init__","title":"<code>__init__(link_factory=lambda x: ClusterLink(**x), node_factory=lambda x: ClusterNode(**x), axis_label_factory=lambda x: AxisLabel(**x))</code>","text":"<p>Initializes the idendrogram object, optionally with different formatting defaults.</p> <p>Parameters:</p> Name Type Description Default <code>link_factory</code> <code>Callable[[Dict], ClusterLink]</code> <p>idendrogram.ClusterLink factory that can be used to override link formatting defaults.                 </p> <code>lambda x: ClusterLink(**x)</code> <code>node_factory</code> <code>Callable[[Dict], ClusterNode]</code> <p>idendrogram.ClusterNode factory that can be used to override node formatting defaults.                 </p> <code>lambda x: ClusterNode(**x)</code> <code>axis_label_factory</code> <code>Callable[[Dict], AxisLabel]</code> <p>idendrogram.AxisLabel factory that can be used to override axis label formatting defaults.                 </p> <code>lambda x: AxisLabel(**x)</code> Example <p>Customizing the Dendrogram to show smaller nodes and dashed link lines:</p> <pre><code>#define a subclass of `ClusterNode` and redefine radius and text label sizes\n@dataclass\nSmallClusterNode(ClusterNode):\n    radius: 3\n    labelsize: 3\n\n#define a subclass of `ClusterLink` and redefine stroke dash pattern\n@dataclass\nDashedLink(ClusterLink):\n    strokedash: List = field(default_factory= lambda: [1, 5, 5, 1])\n\n#instantiate the idendrogram object with the factories for links and nodes\ndd = idendrogram.idendrogram(\n    link_factory=lambda x: DashedLink(**x), \n    node_factory=lambda x: SmallClusterNode(**x)\n)\n\n#proceed as usual\ncdata = idendrogram.ClusteringData(\n    linkage_matrix=model, \n    cluster_assignments=cluster_assignments, \n    threshold=threshold\n)\ndd.set_cluster_info(cdata)\ndendrogram = dd.create_dendrogram().to_altair()\n</code></pre>"},{"location":"reference/reference/#idendrogram.base.idendrogram.convert_scipy_dendrogram","title":"<code>convert_scipy_dendrogram(R, compute_nodes=True, node_label_func=callbacks.cluster_id_if_cluster, node_hover_func=callbacks.default_hover, link_color_func=callbacks.link_painter())</code>","text":"<p>Converts a dictionary representing a dendrogram generated by SciPy to idendrogram.Dendrogram object.</p> <p>Parameters:</p> Name Type Description Default <code>R</code> <code>ScipyDendrogram</code> <p>Dictionary as generated by SciPy's <code>dendrogram(..., no_plot=True)</code> or equivalent</p> required <code>compute_nodes</code> <code>bool</code> <p>Whether to compute nodes (requires idendrogram.ClusteringData to be set via idendrogram.idendrogram.set_cluster_info and can be computationally expensive on large datasets).            </p> <code>True</code> <code>node_label_func</code> <code>Callable[[], str]</code> <p>Callback function to generate dendrogram node labels. See idendrogram.idendrogram.create_dendrogram for usage details.</p> <code>callbacks.cluster_id_if_cluster</code> <code>node_hover_func</code> <code>Callable[[], Union[Dict, str]]</code> <p>Callback function to generate dendrogram hover text labels. See idendrogram.idendrogram.create_dendrogram for usage details.</p> <code>callbacks.default_hover</code> <p>Returns:</p> Name Type Description <code>Dendrogram</code> <code>Dendrogram</code> <p>[idendrogram.Dendrogram] object</p> Example <pre><code>#your clustering workflow\nZ = scipy.cluster.hierarchy.linkage(*)\nthreshold = 42\ncluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, *)\nR = scipy.cluster.hierarchy.dendrogram(Z, no_plot=True, get_leaves=True, *)        \n\n#Render scipy's dendrogram in plotly without any additional modifications\ndd = idendrogram.idendrogram()        \ndendrogram = dd.convert_scipy_dendrogram(R, compute_nodes = False)\ndendrogram.to_plotly()\n\n</code></pre>"},{"location":"reference/reference/#idendrogram.base.idendrogram.create_dendrogram","title":"<code>create_dendrogram(truncate_mode='level', p=4, sort_criteria='distance', sort_descending=False, link_color_func=callbacks.link_painter(), leaf_label_func=callbacks.counts, compute_nodes=True, node_label_func=callbacks.cluster_id_if_cluster, node_hover_func=callbacks.default_hover)</code>","text":"<p>Creates an idendrogram dendrogram object.</p> <p>Parameters:</p> Name Type Description Default <code>truncate_mode</code> <code>level | lastp | None</code> <p>Truncation mode used to condense the dendrogram.  See scipy's dendrogram() for details. </p> <code>'level'</code> <code>p</code> <code>int</code> <p>truncate_mode parameter. See scipy's dendrogram() for details. </p> <code>4</code> <code>sort_criteria</code> <code>count | distance</code> <p>Node order criteria. <code>count</code> sorts by number of original observations in the node,  <code>distance</code> by the distance between direct descendents of the node).             </p> <code>'distance'</code> <code>sort_descending</code> <code>bool</code> <p>Accompanying parameter to sort_criteria to indicate whether sorting should be descending.             </p> <code>False</code> <code>link_color_func</code> <code>Callable[[ClusteringData, int], str]</code> <p>A callable function that determines colors of nodes and links. See below for details. </p> <code>callbacks.link_painter()</code> <code>leaf_label_func</code> <code>Callable[[ClusteringData, int], str]</code> <p>A callable function that determines leaf node labels. See below for details. </p> <code>callbacks.counts</code> <code>compute_nodes</code> <code>bool</code> <p>Whether nodes should be computed (can be computationally expensive on large datasets). </p> <code>True</code> <code>node_label_func</code> <code>Callable[[ClusteringData, int], str]</code> <p>A callable function that determines node text labels. See below for details. </p> <code>callbacks.cluster_id_if_cluster</code> <code>node_hover_func</code> <code>Callable[[ClusteringData, int], Dict[str, str]]</code> <p>A callable function that determines node hover text. See below for details. </p> <code>callbacks.default_hover</code> <p>Returns:</p> Name Type Description <code>Dendrogram</code> <code>Dendrogram</code> <p>[idendrogram.Dendrogram] object</p>"},{"location":"reference/reference/#idendrogram.base.idendrogram.create_dendrogram--usage-notes","title":"Usage notes","text":"<p>For how-to examples, see How-to Guide.</p>"},{"location":"reference/reference/#idendrogram.base.idendrogram.create_dendrogram--scipys-dendrogram-parameters","title":"SciPy's dendrogram parameters","text":"<p>idendrogram uses SciPy to generate the initial dendrogram structure and passes a few parameters directly to <code>scipy.cluster.hierarchy.dendrogram</code>:</p> <ul> <li><code>truncate_mode</code> and <code>p</code> are passed without modifications</li> <li><code>sort_criteria</code> and <code>sort_descending</code> map to <code>count_sort</code> and <code>distance_sort</code></li> <li><code>leaf_color_func</code> and <code>leaf_label_func</code> are passed on with an additional wrapper that enables access to the linkage matrix (see below for details)</li> </ul> <p>To fully understand these parameters, it is easiest to explore scipy's documentation directly.</p>"},{"location":"reference/reference/#idendrogram.base.idendrogram.create_dendrogram--callback-functions","title":"Callback functions","text":"<p>idendrogram uses callbacks to allow customizing link/node colors (<code>link_color_func</code>), leaf axis labels (<code>leaf_label_func</code>),      node labels (<code>node_label_func</code>) and tooltips (<code>node_hover_func</code>). All callback functions will be called with 2 parameters: </p> <ul> <li>an instance of idendrogram.ClusteringData object that provides access to linkage matrix and other clustering information.</li> <li>linkage ID (integer)</li> </ul> <p>The return types should be: </p> <ul> <li><code>link_color_func</code> should return the color for the link/node represented by the linkage ID. </li> <li><code>leaf_label_func</code> should return the text label to be used for the axis label of the leaf node represented by the linkage ID.</li> <li><code>node_label_func</code> should return the text label to be used for the node represented by the linkage ID. </li> <li><code>node_hover_func</code> should return a dictionary of key:value pairs that will be displayed in a tooltip of the node represented by the linkage ID.</li> </ul> <p>This setup allows nearly endless customization - examples are provided in How-to Guide.</p>"},{"location":"reference/reference/#idendrogram.base.idendrogram.set_cluster_info","title":"<code>set_cluster_info(cluster_data)</code>","text":"<p>Sets the clustering data (linkage matrix and other parameters) that are required for some of the dendrogram generation features.</p> <p>Parameters:</p> Name Type Description Default <code>cluster_data</code> <code>ClusteringData</code> <p>instance of idendrogram.ClusteringData</p> required Example <pre><code>#your clustering workflow\nZ = scipy.cluster.hierarchy.linkage(...)\nthreshold = 42\ncluster_assignments =  scipy.cluster.hierarchy.fcluster(Z, threshold=threshold, ...)        \n\n#dendrogram creation\ndd = idendrogram.idendrogram()\ncdata = idendrogram.ClusteringData(\n    linkage_matrix=Z, \n    cluster_assignments=cluster_assignments, \n    threshold=threshold \n)\ndd.set_cluster_info(cdata)\n</code></pre>"}]}